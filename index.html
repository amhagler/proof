<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Geffen Cockpit Dashboard</title>
  <style>
    :root{
      /* Futuristic blue + metallic (FF7-ish mako + steel) */
      --bg0:#070B1A;
      --bg1:#0B1230;
      --panel:#0C1638;
      --panel2:#0A1230;

      --ink:#EAF0FF;
      --muted:#B7C2E6;

      --electric:#2D7DFF;
      --electric2:#1E5BFF;
      --cyan:#7BE7FF;

      --mako:#4BFFD3;
      --brass:#D7B56D;
      --brass2:#8A6B2F;
      --steel:#9AA7C1;
      --steel2:#6D7A96;

      --gold:#FFE066;
      --red:#FF5A5A;

      --line: rgba(255,255,255,.10);
      --line2: rgba(255,255,255,.18);

      --radius: 18px;
      --radius2: 26px;

      --shadow: 0 18px 60px rgba(0,0,0,.55);
      --shadow2: 0 10px 28px rgba(0,0,0,.35);

      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --serif: ui-serif, Georgia, "Times New Roman", serif;

      /* Ring sizing (circular nodes) */
      --ringSize: 720px;
      --nodeW: 132px;
      --nodeH: 132px;
      --ringPad: 40px;

      /* Center holo sizing */
      --holoInset: 200px;

      /* FX */
      --fxGlow: 1;
      --matrixOpacity: .55;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      color:var(--ink);
      font-family:var(--sans);
      background:
        radial-gradient(1200px 700px at 20% 0%, rgba(45,125,255,.16), transparent 55%),
        radial-gradient(1100px 620px at 80% 18%, rgba(123,231,255,.10), transparent 60%),
        radial-gradient(900px 520px at 60% 95%, rgba(215,181,109,.08), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      overflow-x:hidden;
    }

    /* ===== Matrix/electric cascade background ===== */
    #matrixBg{
      position:fixed;
      inset:0;
      z-index:0;
      pointer-events:none;
      opacity: var(--matrixOpacity);
      mix-blend-mode: screen;
      filter: blur(.15px);
    }
    .scanlines, .fog{
      position:fixed;
      inset:0;
      pointer-events:none;
      z-index:1;
    }
    .scanlines{
      background: repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,.03),
        rgba(255,255,255,.03) 1px,
        transparent 1px,
        transparent 3px
      );
      opacity:.14;
      mix-blend-mode: overlay;
    }
    .fog{
      background:
        radial-gradient(1000px 600px at 25% 60%, rgba(123,231,255,.10), transparent 60%),
        radial-gradient(900px 520px at 70% 45%, rgba(45,125,255,.08), transparent 60%),
        radial-gradient(720px 420px at 52% 86%, rgba(75,255,211,.06), transparent 65%),
        radial-gradient(700px 420px at 40% 92%, rgba(215,181,109,.06), transparent 70%);
      filter: blur(12px);
      opacity:.55;
      animation: fogMove 16s ease-in-out infinite alternate;
    }
    @keyframes fogMove{
      from{ transform: translate3d(-10px, 0, 0) scale(1.02); }
      to{ transform: translate3d(14px, -9px, 0) scale(1.03); }
    }

    /* ===== Lightning overlay canvas ===== */
    #fxLightning{
      position:fixed;
      inset:0;
      z-index:10;
      pointer-events:none;
    }

    /* Top bar */
    .topbar{
      position:sticky;
      top:0;
      z-index:6;
      padding: 14px 16px;
      backdrop-filter: blur(10px);
      background: linear-gradient(to bottom, rgba(7,11,26,.80), rgba(7,11,26,.42));
      border-bottom: 1px solid rgba(255,255,255,.10);
    }
    .topbarInner{
      max-width: 1320px;
      margin:0 auto;
      display:flex;
      gap: 14px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
      position:relative;
      z-index:2;
    }

    .brand{
      display:flex;
      flex-direction:column;
      gap:2px;
      min-width: 240px;
    }
    .brand .title{
      font-family: var(--serif);
      letter-spacing:.7px;
      font-weight: 900;
      font-size: 18px;
      line-height:1.1;
      color: var(--ink);
      text-shadow: 0 0 18px rgba(45,125,255,.25);
    }
    .brand .subtitle{
      font-family: var(--mono);
      font-size: 11px;
      color: rgba(234,240,255,.72);
    }

    .clockBox{
      display:flex;
      flex-direction:column;
      gap:8px;
      font-family: var(--mono);
      padding: 10px 12px;
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(12,22,56,.85), rgba(10,18,48,.75));
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: var(--shadow2);
      min-width: 320px;
      justify-content:center;
      position:relative;
      overflow:hidden;
    }
    .clockBox::before{
      content:"";
      position:absolute;
      inset: -2px;
      background:
        radial-gradient(220px 70px at 20% 25%, rgba(215,181,109,.10), transparent 70%),
        radial-gradient(240px 90px at 75% 65%, rgba(75,255,211,.07), transparent 70%);
      pointer-events:none;
      opacity:.9;
    }
    .clockTop{
      display:flex;
      gap:10px;
      align-items:baseline;
      justify-content:center;
      position:relative;
      z-index:2;
    }
    .clockBox .date{ color: rgba(234,240,255,.75); font-size: 12px; }
    .clockBox .time{ color: var(--ink); font-size: 15px; font-weight: 900; }
    .clockBox .ticks{ color: rgba(123,231,255,.85); font-size: 12px; }

    @keyframes warnPulse{
      0%, 100% { box-shadow: 0 0 0 1px rgba(255,255,255,.14) inset, 0 10px 22px rgba(0,0,0,.35); }
      50% { box-shadow: 0 0 0 1px rgba(123,231,255,.22) inset, 0 0 18px rgba(45,125,255,.32), 0 10px 22px rgba(0,0,0,.35); }
    }
    .countdown{
      display:flex;
      justify-content:center;
      gap:8px;
      font-size: 11px;
      color: rgba(234,240,255,.74);
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      position:relative;
      overflow:hidden;
      z-index:2;
    }
    .countdown b{ color: rgba(234,240,255,.92); }
    .countdown.warn{
      border-color: rgba(123,231,255,.22);
      animation: warnPulse 1.6s ease-in-out infinite;
    }

    .nextClassCard{
      display:none;
      position:relative;
      z-index:2;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      box-shadow: 0 0 0 1px rgba(45,125,255,.08) inset, 0 10px 22px rgba(0,0,0,.22);
      padding: 9px 10px;
      font-family: var(--mono);
      font-size: 11px;
      color: rgba(234,240,255,.78);
      overflow:hidden;
    }
    .nextClassCard.on{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .nextClassCard .meta{
      min-width:0;
      display:flex;
      flex-direction:column;
      gap:2px;
    }
    .nextClassCard .meta b{
      font-size: 11px;
      color: rgba(234,240,255,.92);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .nextClassCard .meta span{
      font-size: 10px;
      color: rgba(234,240,255,.66);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .nextClassCard .openBtn{
      border:none;
      cursor:pointer;
      font-family: var(--mono);
      font-size: 11px;
      font-weight: 900;
      padding: 8px 10px;
      border-radius: 12px;
      color:#07101f;
      background: linear-gradient(180deg, rgba(123,231,255,.95), rgba(45,125,255,.92));
      box-shadow: 0 0 0 1px rgba(255,255,255,.14) inset, 0 12px 22px rgba(0,0,0,.28);
      white-space:nowrap;
    }
    .nextClassCard .openBtn:active{ transform: translateY(1px); }

    .searchWrap{
      flex: 1;
      min-width: 280px;
      max-width: 580px;
      display:flex;
      align-items:center;
      gap:10px;
      padding: 10px 12px;
      border-radius: 999px;
      background: linear-gradient(180deg, rgba(12,22,56,.85), rgba(10,18,48,.70));
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: var(--shadow2);
      position:relative;
      overflow:hidden;
    }
    .searchWrap::before{
      content:"";
      position:absolute;
      inset:-1px;
      background:
        radial-gradient(300px 80px at 25% 10%, rgba(215,181,109,.09), transparent 70%),
        radial-gradient(260px 90px at 70% 90%, rgba(75,255,211,.06), transparent 70%);
      opacity:.9;
      pointer-events:none;
    }
    .searchWrap .lens{
      width: 18px; height: 18px;
      border-radius: 50%;
      border: 2px solid rgba(123,231,255,.75);
      position:relative;
      opacity:.95;
      flex: 0 0 auto;
      z-index:2;
    }
    .searchWrap .lens:after{
      content:"";
      position:absolute;
      width: 10px; height: 2px;
      background: rgba(123,231,255,.75);
      right:-8px; bottom:-3px;
      transform: rotate(45deg);
      border-radius: 3px;
    }
    .searchWrap input{
      flex:1;
      background: transparent;
      border: none;
      outline:none;
      color: var(--ink);
      font-family: var(--mono);
      font-size: 13px;
      position:relative;
      z-index:2;
    }
    .searchWrap button{
      border:none;
      cursor:pointer;
      color: #07101f;
      font-weight: 900;
      font-family: var(--mono);
      font-size: 12px;
      padding: 8px 12px;
      border-radius: 999px;
      background: linear-gradient(180deg, rgba(123,231,255,.95), rgba(45,125,255,.92));
      box-shadow: 0 0 0 1px rgba(255,255,255,.12) inset, 0 10px 22px rgba(0,0,0,.35);
      transition: transform .08s ease, filter .18s ease;
      flex: 0 0 auto;
      position:relative;
      z-index:2;
    }
    .searchWrap button:hover{ filter: brightness(1.05); }
    .searchWrap button:active{ transform: translateY(1px); }

    /* FX intensity control (unobtrusive) */
    .fxCtl{
      display:flex;
      align-items:center;
      gap:10px;
      padding: 10px 12px;
      border-radius: 999px;
      background: linear-gradient(180deg, rgba(12,22,56,.82), rgba(10,18,48,.68));
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: var(--shadow2);
      font-family: var(--mono);
      font-size: 11px;
      color: rgba(234,240,255,.74);
      position:relative;
      overflow:hidden;
      min-width: 210px;
    }
    .fxCtl::before{
      content:"";
      position:absolute;
      inset:-1px;
      background:
        radial-gradient(220px 70px at 20% 20%, rgba(45,125,255,.12), transparent 70%),
        radial-gradient(220px 70px at 85% 80%, rgba(215,181,109,.07), transparent 75%);
      opacity:.85;
      pointer-events:none;
    }
    .fxCtl .fxIcon{
      width: 24px;
      height: 24px;
      border-radius: 10px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight: 900;
      color:#07101f;
      background: linear-gradient(180deg, rgba(123,231,255,.95), rgba(45,125,255,.92));
      box-shadow: 0 0 0 1px rgba(255,255,255,.14) inset, 0 10px 18px rgba(0,0,0,.25);
      position:relative;
      z-index:2;
      flex: 0 0 auto;
    }
    .fxCtl input[type="range"]{
      width: 110px;
      position:relative;
      z-index:2;
      accent-color: var(--cyan);
    }
    .fxCtl .fxLbl{
      position:relative;
      z-index:2;
      min-width: 64px;
      text-align:right;
      color: rgba(234,240,255,.80);
      font-weight: 900;
      letter-spacing:.06em;
    }

    /* Main layout */
    .shell{
      position:relative;
      z-index:3;
      max-width: 1320px;
      margin: 18px auto 40px auto;
      padding: 0 16px;
      display:grid;
      grid-template-columns: 1.15fr .85fr;
      gap: 16px;
      align-items:start;
    }
    @media (max-width: 1040px){
      .shell{ grid-template-columns: 1fr; }
      :root{ --ringSize: 640px; --holoInset: 185px; --nodeW:124px; --nodeH:124px; }
    }
    @media (max-width: 680px){
      :root{ --ringSize: 580px; --holoInset: 172px; --nodeW:116px; --nodeH:116px; }
      .fxCtl{ min-width: 100%; }
    }

    /* Left: ring bay */
    .bay{
      position:relative;
      border-radius: var(--radius2);
      background: linear-gradient(180deg, rgba(12,22,56,.76), rgba(10,18,48,.62));
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: var(--shadow);
      overflow: visible;
      min-height: calc(var(--ringSize) + 140px);
    }
    .bay::before{
      content:"";
      position:absolute;
      inset:-2px;
      border-radius: var(--radius2);
      background:
        radial-gradient(920px 420px at 25% 30%, rgba(45,125,255,.20), transparent 60%),
        radial-gradient(720px 360px at 70% 60%, rgba(123,231,255,.14), transparent 55%),
        radial-gradient(520px 320px at 50% 90%, rgba(215,181,109,.10), transparent 60%);
      filter: blur(10px);
      opacity:.95;
      pointer-events:none;
      z-index:0;
    }
    .bay .trim{
      position:absolute;
      inset:10px;
      border-radius: calc(var(--radius2) - 6px);
      border: 1px solid rgba(215,181,109,.20);
      box-shadow: 0 0 0 1px rgba(0,0,0,.22) inset;
      pointer-events:none;
      z-index:1;
      opacity:.85;
    }

    .bayHeader{
      position:relative;
      z-index:4;
      padding: 14px 14px 12px 14px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      background: linear-gradient(to bottom, rgba(255,255,255,.06), transparent);
      border-radius: var(--radius2);
      flex-wrap:wrap;
    }
    .bayHeader .h1{
      display:flex;
      flex-direction:column;
      gap:3px;
      min-width: 260px;
    }
    .bayHeader .h1 b{
      font-family: var(--mono);
      letter-spacing:.14em;
      text-transform: uppercase;
      font-size: 12px;
      color: rgba(234,240,255,.85);
    }
    .bayHeader .h1 span{
      font-size: 12px;
      color: rgba(234,240,255,.70);
    }

    .bayHeader .datePick{
      display:flex;
      flex-direction:column;
      gap:8px;
      align-items:flex-end;
      font-family: var(--mono);
      font-size: 11px;
      color: rgba(234,240,255,.70);
      min-width: 340px;
    }
    .bayHeader .datePickRow{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .bayHeader input[type="date"]{
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(7,11,26,.25);
      color: var(--ink);
      padding: 8px 10px;
      font-family: var(--mono);
      font-size: 12px;
      outline:none;
    }
    .bayHeader input[type="date"]:focus{
      border-color: rgba(123,231,255,.30);
      box-shadow: 0 0 0 4px rgba(45,125,255,.18);
    }

    .quickBtn{
      border:none;
      cursor:pointer;
      font-family: var(--mono);
      font-size: 11px;
      font-weight: 900;
      padding: 8px 10px;
      border-radius: 999px;
      color: rgba(234,240,255,.88);
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: 0 0 0 1px rgba(0,0,0,.16) inset;
      transition: filter .18s ease, transform .08s ease;
      user-select:none;
      white-space:nowrap;
    }
    .quickBtn:hover{ filter: brightness(1.05); }
    .quickBtn:active{ transform: translateY(1px); }
    .quickBtn.primary{
      color:#07101f;
      background: linear-gradient(180deg, rgba(123,231,255,.95), rgba(45,125,255,.92));
      border-color: rgba(255,255,255,.10);
      box-shadow: 0 0 0 1px rgba(255,255,255,.14) inset, 0 12px 22px rgba(0,0,0,.26);
    }

    .ringStage{
      position:relative;
      z-index:2;
      height: calc(var(--ringSize) + 16px);
      display:flex;
      align-items:center;
      justify-content:center;
      padding: calc(var(--ringPad) + 10px) var(--ringPad) 18px var(--ringPad);
      user-select:none;
    }

    .ring{
      width: var(--ringSize);
      height: var(--ringSize);
      border-radius: 50%;
      position:relative;
      transform: translateZ(0);
      outline:none;
    }

    /* Track / ring face */
    .ring:before{
      content:"";
      position:absolute;
      inset: 22px;
      border-radius:50%;
      border: 1px solid rgba(123,231,255,.22);
      box-shadow:
        0 0 0 1px rgba(45,125,255,.16) inset,
        0 0 26px rgba(45,125,255,.14),
        0 0 80px rgba(45,125,255,.08);
      background:
        radial-gradient(circle at 50% 50%, rgba(12,22,56,.40), rgba(7,11,26,.55));
      z-index:0;
    }
    .ring:after{
      content:"";
      position:absolute;
      inset: 64px;
      border-radius:50%;
      border: 1px dashed rgba(215,181,109,.18);
      box-shadow: 0 0 0 1px rgba(255,255,255,.06) inset;
      opacity:.9;
      pointer-events:none;
      z-index:0;
    }

    /* Center holo */
    .holo{
      position:absolute;
      inset: var(--holoInset);
      border-radius: 22px;
      background: linear-gradient(180deg, rgba(12,22,56,.30), rgba(10,18,48,.14));
      border: 1px solid rgba(255,255,255,.08);
      box-shadow: 0 0 0 1px rgba(45,125,255,.08) inset;
      backdrop-filter: blur(8px);
      display:flex;
      flex-direction:column;
      gap:8px;
      padding: 10px;
      pointer-events:auto;
      z-index:2;
      opacity:.92;
      min-height: 220px;
    }
    .holo .holoTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .holo .tag{
      font-family: var(--mono);
      font-size: 10px;
      letter-spacing:.14em;
      text-transform: uppercase;
      color: rgba(123,231,255,.82);
    }
    .holo .sub{
      font-family: var(--mono);
      font-size: 10px;
      color: rgba(234,240,255,.60);
      white-space:nowrap;
    }

    /* schedule block list wrapper so we can place the time marker */
    .holoListWrap{
      position:relative;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.08);
      background: rgba(255,255,255,.03);
      overflow:hidden;
      flex: 1;
      min-height: 0;
    }
    .holoList{
      display:grid;
      gap: 6px;
      padding: 10px;
      font-family: var(--mono);
      font-size: 11px;
      color: rgba(234,240,255,.82);
      height: 100%;
      overflow:auto;
      scrollbar-width: thin;
      scrollbar-color: rgba(123,231,255,.35) rgba(0,0,0,.0);
      line-height: 1.12;
    }
    .holoList::-webkit-scrollbar{ width: 10px; }
    .holoList::-webkit-scrollbar-thumb{
      background: rgba(123,231,255,.24);
      border-radius: 999px;
      border: 3px solid rgba(0,0,0,.0);
      background-clip: padding-box;
    }
    .holoList::-webkit-scrollbar-track{ background: transparent; }

    .periodCard{
      position:relative;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      padding: 8px 10px;
      display:flex;
      gap:10px;
      align-items:flex-start;
      box-shadow: 0 0 0 1px rgba(45,125,255,.06) inset;
    }
    .periodCard .t{
      flex: 0 0 auto;
      min-width: 78px;
      color: rgba(234,240,255,.72);
      font-size: 10px;
      letter-spacing:.03em;
      margin-top: 1px;
    }
    .periodCard .lbl{
      flex:1;
      min-width:0;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .periodCard.misc{
      opacity:.78;
      border-color: rgba(255,255,255,.08);
    }
    .periodCard.named{
      border-color: rgba(123,231,255,.22);
      box-shadow:
        0 0 0 1px rgba(45,125,255,.10) inset,
        0 0 18px rgba(45,125,255,.10);
      background:
        radial-gradient(220px 70px at 25% 0%, rgba(45,125,255,.12), transparent 70%),
        linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
    }
    .periodCard.now{
      border-color: rgba(215,181,109,.25);
      box-shadow:
        0 0 0 1px rgba(215,181,109,.14) inset,
        0 0 22px rgba(215,181,109,.10);
    }
    .periodCard a.periodLink{
      color: rgba(234,240,255,.92);
      text-decoration:none;
      display:inline-flex;
      gap:8px;
      align-items:center;
      min-width:0;
    }
    .periodCard a.periodLink:hover{
      text-decoration: underline;
      text-decoration-color: rgba(123,231,255,.55);
      text-underline-offset: 3px;
    }
    .linkBadge{
      flex: 0 0 auto;
      font-size: 10px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(123,231,255,.22);
      color: rgba(123,231,255,.92);
      background: rgba(45,125,255,.10);
      white-space:nowrap;
    }

    /* time marker (blue “cursor” that slides down schedule for today) */
    .timeMarker{
      position:absolute;
      left: 8px;
      right: 8px;
      height: 0;
      top: 0;
      pointer-events:none;
      z-index:5;
      opacity:0;
      transition: opacity .25s ease;
    }
    .timeMarker.on{ opacity: 1; }
    .timeMarker .bar{
      position:absolute;
      left: 0;
      right: 0;
      top: -1px;
      height: 2px;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(123,231,255,.0), rgba(123,231,255,.75), rgba(45,125,255,.75), rgba(75,255,211,.45), rgba(123,231,255,.0));
      box-shadow: 0 0 calc(16px * var(--fxGlow)) rgba(45,125,255,.25);
      filter: blur(.05px);
    }
    .timeMarker .dot{
      position:absolute;
      top: -6px;
      left: 10px;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: rgba(123,231,255,.92);
      box-shadow: 0 0 calc(18px * var(--fxGlow)) rgba(45,125,255,.38);
      border: 1px solid rgba(255,255,255,.18);
    }
    .timeMarker .tag{
      position:absolute;
      top: -14px;
      right: 10px;
      font-family: var(--mono);
      font-size: 10px;
      color: rgba(234,240,255,.78);
      background: rgba(7,11,26,.45);
      border: 1px solid rgba(255,255,255,.10);
      padding: 3px 8px;
      border-radius: 999px;
      backdrop-filter: blur(6px);
    }

    /* orbit nodes */
    .node{
      position:absolute;
      width: var(--nodeW);
      height: var(--nodeH);
      left: 50%;
      top: 50%;
      transform: translate(-50%,-50%);
      will-change: transform;
      cursor:pointer;
      z-index:5;
      touch-action:none;
    }
    .node.dragging{ z-index: 20; }
    .node .cardLink:focus{ outline:none; }
    .node.focused .cardLink{
      border-color: rgba(123,231,255,.34);
      box-shadow:
        0 0 0 1px rgba(45,125,255,.14) inset,
        0 0 22px rgba(45,125,255,.14),
        0 16px 28px rgba(0,0,0,.42);
      filter: brightness(1.06);
    }

    /* Circular rotating cards */
    .cardLink{
      width: 100%;
      height: 100%;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:8px;
      padding: 12px 10px;
      border-radius: 50%;
      text-decoration:none;
      color: var(--ink);
      background:
        radial-gradient(90px 70px at 35% 25%, rgba(123,231,255,.18), transparent 70%),
        radial-gradient(90px 70px at 70% 75%, rgba(215,181,109,.10), transparent 75%),
        linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03)),
        linear-gradient(180deg, rgba(12,22,56,.82), rgba(10,18,48,.72));
      border: 1px solid rgba(255,255,255,.14);
      box-shadow:
        0 0 0 1px rgba(45,125,255,.10) inset,
        0 16px 28px rgba(0,0,0,.42);
      transition: transform .12s ease, border-color .18s ease, filter .18s ease;
      position:relative;
      overflow:hidden;
      pointer-events:auto;
      user-select:none;
    }
    .cardLink::after{
      content:"";
      position:absolute;
      inset:-1px;
      border-radius: 50%;
      background:
        radial-gradient(22px 12px at 22% 30%, rgba(123,231,255,0), rgba(123,231,255,0) 60%, rgba(123,231,255,.18) 66%, rgba(123,231,255,0) 80%),
        radial-gradient(22px 12px at 78% 62%, rgba(45,125,255,0), rgba(45,125,255,0) 60%, rgba(45,125,255,.14) 66%, rgba(45,125,255,0) 80%);
      opacity:.0;
      pointer-events:none;
      transition: opacity .18s ease;
    }
    .cardLink:hover{
      transform: translateY(-2px) scale(1.01);
      border-color: rgba(123,231,255,.30);
      filter: brightness(1.06);
    }
    .cardLink:hover::after{ opacity:.9; }
    .cardLink:active{
      transform: translateY(-1px) scale(1.005);
    }
    .cardTitle{
      font-family: var(--mono);
      font-size: 11px;
      letter-spacing:.08em;
      text-transform: uppercase;
      text-align:center;
      line-height:1.15;
      padding: 0 6px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 100%;
    }
    .cardSub{
      font-family: var(--mono);
      font-size: 9px;
      color: rgba(234,240,255,.70);
      text-align:center;
      padding: 0 8px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 100%;
    }
    .glyph{
      width: 40px;
      height: 40px;
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(215,181,109,.92), rgba(138,107,47,.74));
      box-shadow: 0 0 0 1px rgba(255,255,255,.14) inset, 0 10px 18px rgba(0,0,0,.35);
      display:flex;
      align-items:center;
      justify-content:center;
      color:#120f07;
      font-weight: 900;
      font-family: var(--mono);
      flex: 0 0 auto;
    }

    /* energy bar */
    .energyWrap{
      position:relative;
      z-index:4;
      padding: 0 14px 14px 14px;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .energyBar{
      width: min(760px, 92%);
      height: 14px;
      border-radius: 999px;
      background: rgba(255,255,255,.07);
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: 0 0 0 1px rgba(0,0,0,.18) inset;
      position:relative;
      overflow:hidden;
    }
    .energyFill{
      height: 100%;
      width: 0%;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(123,231,255,.95), rgba(45,125,255,.92), rgba(75,255,211,.62));
      box-shadow: 0 0 calc(22px * var(--fxGlow)) rgba(45,125,255,.24);
      transition: width 1.2s ease;
      position:relative;
    }
    .energyMeta{
      margin-top: 8px;
      width: min(760px, 92%);
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-family: var(--mono);
      font-size: 11px;
      color: rgba(234,240,255,.70);
    }
    .energyMeta b{ color: rgba(234,240,255,.88); }

    /* Right cockpit panel */
    .cockpit{
      border-radius: var(--radius2);
      background: linear-gradient(180deg, rgba(12,22,56,.82), rgba(10,18,48,.70));
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }
    .cockpit::before{
      content:"";
      position:absolute;
      inset:-2px;
      background:
        radial-gradient(620px 360px at 30% 10%, rgba(123,231,255,.14), transparent 60%),
        radial-gradient(520px 260px at 70% 80%, rgba(215,181,109,.08), transparent 65%);
      filter: blur(10px);
      opacity:.9;
      pointer-events:none;
    }

    .cockHeader{
      position:relative;
      z-index:2;
      padding: 14px 14px 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 10px;
      background: linear-gradient(to bottom, rgba(255,255,255,.06), transparent);
    }
    .cockHeader .left{
      display:flex;
      flex-direction:column;
      gap: 4px;
    }
    .cockHeader .left b{
      font-family: var(--mono);
      letter-spacing:.14em;
      text-transform: uppercase;
      font-size: 12px;
      color: rgba(234,240,255,.85);
    }
    .cockHeader .left span{
      font-size: 12px;
      color: rgba(234,240,255,.70);
    }

    .pill{
      font-family: var(--mono);
      font-size: 11px;
      color: rgba(234,240,255,.72);
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      border-radius: 999px;
      padding: 8px 10px;
      display:inline-flex;
      align-items:center;
      gap: 8px;
      box-shadow: 0 0 0 1px rgba(0,0,0,.14) inset;
      white-space:nowrap;
      position:relative;
      overflow:hidden;
      z-index:2;
    }
    .pill .spark{
      width: 8px; height: 8px; border-radius:50%;
      background: rgba(123,231,255,.95);
      box-shadow: 0 0 12px rgba(123,231,255,.35);
    }

    .cockBody{
      position:relative;
      z-index:2;
      padding: 14px;
      display:grid;
      gap: 12px;
    }

    .module{
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      box-shadow: 0 0 0 1px rgba(45,125,255,.08) inset, 0 12px 26px rgba(0,0,0,.28);
      overflow:hidden;
      position:relative;
    }
    .module::before{
      content:"";
      position:absolute;
      inset:-1px;
      background:
        radial-gradient(280px 80px at 20% 10%, rgba(215,181,109,.08), transparent 70%),
        radial-gradient(240px 70px at 85% 85%, rgba(75,255,211,.05), transparent 70%);
      opacity:.9;
      pointer-events:none;
    }

    .moduleHd{
      padding: 12px 12px 10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      background: linear-gradient(to bottom, rgba(255,255,255,.06), transparent);
      position:relative;
      z-index:2;
    }
    .moduleHd b{
      font-family: var(--mono);
      font-size: 12px;
      letter-spacing:.14em;
      text-transform: uppercase;
      color: rgba(123,231,255,.88);
    }
    .moduleHd .mini{
      display:flex;
      gap: 8px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    .btn{
      border:none;
      cursor:pointer;
      font-family: var(--mono);
      font-size: 12px;
      font-weight: 900;
      padding: 9px 10px;
      border-radius: 14px;
      transition: transform .08s ease, filter .18s ease, background .18s ease;
      user-select:none;
      white-space:nowrap;
      position:relative;
      z-index:2;
    }
    .btn:active{ transform: translateY(1px); }

    .btnPrimary{
      color:#07101f;
      background: linear-gradient(180deg, rgba(123,231,255,.95), rgba(45,125,255,.92));
      box-shadow: 0 0 0 1px rgba(255,255,255,.14) inset, 0 12px 22px rgba(0,0,0,.34);
    }
    .btnGhost{
      color: rgba(234,240,255,.88);
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: 0 0 0 1px rgba(0,0,0,.16) inset;
    }
    .btnDanger{
      color: rgba(255,90,90,.95);
      background: rgba(255,90,90,.08);
      border: 1px solid rgba(255,90,90,.22);
      box-shadow: 0 0 0 1px rgba(0,0,0,.14) inset;
    }
    .btnGhost:hover,.btnPrimary:hover{ filter: brightness(1.05); }

    .moduleBd{
      padding: 12px;
      display:grid;
      gap: 10px;
      position:relative;
      z-index:2;
    }

    label{
      display:block;
      font-family: var(--mono);
      font-size: 11px;
      letter-spacing:.06em;
      text-transform: uppercase;
      color: rgba(234,240,255,.70);
      margin: 0 0 6px 0;
    }
    input[type="text"], select, textarea{
      width:100%;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(7,11,26,.35);
      color: var(--ink);
      padding: 10px 10px;
      outline:none;
      font-family: var(--mono);
      font-size: 13px;
      transition: box-shadow .15s ease, border-color .15s ease;
      position:relative;
      z-index:2;
    }
    input[type="text"]:focus, select:focus, textarea:focus{
      border-color: rgba(123,231,255,.30);
      box-shadow: 0 0 0 4px rgba(45,125,255,.18);
    }
    textarea{ min-height: 120px; resize: vertical; }

    /* Checklist */
    .checkTop{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .checkTop input{ flex:1; }
    .checkFilters{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
      margin-top: 2px;
    }
    .filterPill{
      border:none;
      cursor:pointer;
      font-family: var(--mono);
      font-size: 11px;
      font-weight: 900;
      padding: 7px 10px;
      border-radius: 999px;
      color: rgba(234,240,255,.82);
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: 0 0 0 1px rgba(0,0,0,.14) inset;
      user-select:none;
    }
    .filterPill.active{
      color:#07101f;
      background: linear-gradient(180deg, rgba(123,231,255,.95), rgba(45,125,255,.92));
      border-color: rgba(255,255,255,.10);
      box-shadow: 0 0 0 1px rgba(255,255,255,.14) inset, 0 10px 18px rgba(0,0,0,.22);
    }

    .checkList{
      display:grid;
      gap: 8px;
      margin-top: 2px;
    }
    .checkItem{
      display:flex;
      gap:10px;
      align-items:flex-start;
      padding: 10px 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(234,240,255,.86);
    }
    .checkItem.overdue{
      border-color: rgba(255,90,90,.22);
      box-shadow: 0 0 0 1px rgba(255,90,90,.08) inset;
    }
    .checkItem input[type="checkbox"]{
      width: 18px; height: 18px;
      margin-top: 2px;
      accent-color: var(--cyan);
      flex: 0 0 auto;
    }
    .dragGrip{
      width: 20px;
      height: 20px;
      border-radius: 10px;
      display:flex;
      align-items:center;
      justify-content:center;
      color: rgba(234,240,255,.70);
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      box-shadow: 0 0 0 1px rgba(0,0,0,.10) inset;
      user-select:none;
      cursor: grab;
      margin-top: 1px;
      flex: 0 0 auto;
    }
    .checkItem.dragging{ opacity:.75; cursor: grabbing; }
    .checkItem .txtWrap{
      flex:1;
      min-width:0;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .checkItem .txt{
      line-height:1.25;
      word-break: break-word;
    }
    .checkMetaRow{
      display:flex;
      gap:6px;
      flex-wrap:wrap;
      align-items:center;
    }
    .tagChip{
      font-size: 10px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(123,231,255,.22);
      color: rgba(123,231,255,.92);
      background: rgba(45,125,255,.10);
      white-space:nowrap;
    }
    .dueBadge{
      font-size: 10px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(215,181,109,.20);
      color: rgba(234,240,255,.82);
      background: rgba(215,181,109,.06);
      white-space:nowrap;
    }
    .dueBadge.overdue{
      border-color: rgba(255,90,90,.22);
      background: rgba(255,90,90,.06);
    }

    .checkItem.done{
      opacity:.68;
      border-color: rgba(255,255,255,.10);
    }
    .checkItem.done .txt{
      text-decoration: line-through;
      color: rgba(183,194,230,.76);
    }

    .tinyHint{
      font-family: var(--mono);
      font-size: 11px;
      color: rgba(234,240,255,.62);
      line-height:1.25;
      position:relative;
      z-index:2;
    }

    /* Ring node editor */
    .ringList{
      display:grid;
      gap:8px;
    }
    .ringRow{
      display:flex;
      gap:10px;
      align-items:center;
    }
    .ringRow .miniNote{
      font-family: var(--mono);
      font-size: 11px;
      color: rgba(234,240,255,.62);
      line-height:1.2;
    }
    .ringSelect{
      width:100%;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(7,11,26,.35);
      color: var(--ink);
      padding: 10px 10px;
      outline:none;
      font-family: var(--mono);
      font-size: 13px;
    }

    /* Export / import drawer */
    .overlay{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      z-index: 50;
      padding: 18px;
    }
    .modal{
      width: min(860px, 96vw);
      border-radius: 22px;
      background: linear-gradient(180deg, rgba(12,22,56,.92), rgba(10,18,48,.88));
      border: 1px solid rgba(255,255,255,.16);
      box-shadow: 0 24px 80px rgba(0,0,0,.60);
      overflow:hidden;
    }
    .modalHd{
      padding: 14px 14px 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,.12);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .modalHd b{
      font-family: var(--mono);
      letter-spacing:.14em;
      text-transform: uppercase;
      font-size: 12px;
      color: rgba(123,231,255,.90);
    }
    .modalBd{
      padding: 14px;
      display:grid;
      gap: 10px;
    }

    .footer{
      max-width: 1320px;
      margin: 0 auto;
      padding: 0 16px 26px 16px;
      color: rgba(183,194,230,.72);
      font-family: var(--mono);
      font-size: 11px;
      text-align:center;
      z-index:3;
      position:relative;
    }
  </style>
</head>

<body>
  <!-- Matrix/electric cascade background -->
  <canvas id="matrixBg" aria-hidden="true"></canvas>

  <!-- Atmospheric overlays -->
  <div class="fog" aria-hidden="true"></div>
  <div class="scanlines" aria-hidden="true"></div>

  <!-- Lightning canvas -->
  <canvas id="fxLightning" aria-hidden="true"></canvas>

  <div class="topbar">
    <div class="topbarInner">
      <div class="brand">
        <div class="title">GEFFEN COCKPIT</div>
        <div class="subtitle">Wheel rotates ring • drag nodes to reorder • “/” focuses search • ←/→ rotate • Enter opens</div>
      </div>

      <form class="searchWrap" action="https://www.google.com/search" method="GET" target="_blank" rel="noopener">
        <div class="lens" aria-hidden="true"></div>
        <input id="googleQ" name="q" type="text" placeholder="Search Google…" autocomplete="off" />
        <button type="submit">SEARCH</button>
      </form>

      <div class="fxCtl" aria-label="FX intensity">
        <div class="fxIcon" aria-hidden="true">FX</div>
        <input id="fxRange" type="range" min="0" max="3" step="1" value="2" />
        <div class="fxLbl" id="fxLabel">MED</div>
      </div>

      <div class="clockBox" aria-label="Clock">
        <div class="clockTop">
          <div class="date" id="dateStr">—</div>
          <div class="time" id="timeStr">—</div>
          <div class="ticks" id="ticksStr">.00</div>
        </div>
        <div class="countdown" id="countdownBox">
          <span>Time until next class:</span> <b id="countdownText">—</b>
        </div>
        <div class="nextClassCard" id="nextClassCard">
          <div class="meta">
            <b id="nextClassTitle">—</b>
            <span id="nextClassSub">—</span>
          </div>
          <button class="openBtn" id="nextClassOpenBtn" type="button" style="display:none;">OPEN</button>
        </div>
      </div>
    </div>
  </div>

  <main class="shell">
    <!-- LEFT: Ring bay -->
    <section class="bay" id="bay">
      <div class="trim" aria-hidden="true"></div>

      <div class="bayHeader">
        <div class="h1">
          <b>Navigation Ring</b>
          <span>Wheel rotates. Drag nodes to reorder. Click node to launch.</span>
        </div>

        <div class="datePick" aria-label="Select date to view schedule">
          <div style="opacity:.85;">View date</div>
          <div class="datePickRow">
            <input type="date" id="viewDate" />
            <button class="quickBtn primary" id="btnToday" type="button">Today</button>
            <button class="quickBtn" id="btnTomorrow" type="button">Tomorrow</button>
            <button class="quickBtn" id="btnNextSchool" type="button">Next school day</button>
            <button class="quickBtn" id="btnScrollNow" type="button" title="Today only">Auto-scroll to now</button>
            <button class="quickBtn" id="btnJumpNext" type="button" title="Today only">Jump next class</button>
          </div>
        </div>
      </div>

      <div class="ringStage">
        <div class="ring" id="ring" aria-label="Link ring" tabindex="0">
          <!-- center holo -->
          <div class="holo" id="holo">
            <div class="holoTop">
              <div class="tag" id="holoTag">Daily Schedule</div>
              <div class="sub" id="holoStatus">—</div>
            </div>

            <div class="holoListWrap">
              <div class="timeMarker" id="timeMarker" aria-hidden="true">
                <div class="bar"></div>
                <div class="dot"></div>
                <div class="tag" id="timeMarkerTag">NOW</div>
              </div>
              <div class="holoList" id="holoList" aria-label="Daily schedule">
                <div class="periodCard misc">
                  <div class="t">—</div>
                  <div class="lbl">Enter your schedule on the right.</div>
                </div>
              </div>
            </div>
          </div>

          <!-- nodes inserted by JS -->
        </div>
      </div>

      <div class="energyWrap">
        <div style="width:100%;display:flex;flex-direction:column;align-items:center;">
          <div class="energyBar" aria-label="Energy bar">
            <div class="energyFill" id="energyFill"></div>
          </div>
          <div class="energyMeta">
            <div><b>ENERGY GRID</b> <span id="energyPct">0%</span></div>
            <div id="energyNote">Awaiting schedule…</div>
          </div>
        </div>
      </div>
    </section>

    <!-- RIGHT: Cockpit -->
    <aside class="cockpit" id="cockpit">
      <div class="cockHeader">
        <div class="left">
          <b>Control Console</b>
          <span>Checklist + ring nodes + schedule entry. Everything saves locally.</span>
        </div>
        <div class="pill"><span class="spark"></span><span id="dayModePill">—</span></div>
      </div>

      <div class="cockBody">
        <!-- CHECKLIST MODULE -->
        <div class="module">
          <div class="moduleHd">
            <b>Checklist</b>
            <div class="mini">
              <button class="btn btnGhost" id="clearCheckedBtn" type="button">Clear</button>
              <button class="btn btnGhost" id="exportChecklistBtn" type="button">Export</button>
            </div>
          </div>
          <div class="moduleBd">
            <div class="checkTop">
              <input id="newItemText" type="text" placeholder="Add an agenda item… (use #tags and @due)" />
              <button class="btn btnPrimary" id="addItemBtn" type="button">Add Item</button>
            </div>

            <div class="checkFilters" id="checkFilters"></div>

            <div class="checkList" id="checkList"></div>

            <div class="tinyHint">
              Tip: Enter to add. Use <b>#tag</b> for tag chips, and due tokens like <b>@2:15</b>, <b>@14:15</b>, <b>@today</b>, <b>@tomorrow</b>. Drag grip to reorder.
            </div>
          </div>
        </div>

        <!-- RING NODES MODULE -->
        <div class="module">
          <div class="moduleHd">
            <b>Ring Nodes</b>
            <div class="mini">
              <button class="btn btnGhost" id="ringNewBtn" type="button">New</button>
              <button class="btn btnPrimary" id="ringSaveBtn" type="button">Save</button>
              <button class="btn btnDanger" id="ringDeleteBtn" type="button">Delete</button>
            </div>
          </div>
          <div class="moduleBd">
            <div class="ringRow">
              <select class="ringSelect" id="ringSelect" aria-label="Select ring node"></select>
            </div>

            <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
              <div>
                <label>Label</label>
                <input id="ringLabel" type="text" placeholder="Node label" />
              </div>
              <div>
                <label>Glyph</label>
                <input id="ringGlyph" type="text" placeholder="2–3 chars" />
              </div>
            </div>

            <div>
              <label>Subtext</label>
              <input id="ringSub" type="text" placeholder="Short hint text" />
            </div>

            <div>
              <label>URL</label>
              <input id="ringHref" type="text" placeholder="https://..." />
            </div>

            <div class="tinyHint">Drag nodes on the ring to reorder (persists). Use this panel to add/edit/delete.</div>
          </div>
        </div>

        <!-- Portability (schedule + checklist + ring nodes) -->
        <div class="module">
          <div class="moduleHd">
            <b>Portability</b>
            <div class="mini">
              <button class="btn btnGhost" id="exportBtn" type="button">Export</button>
              <button class="btn btnGhost" id="importBtn" type="button">Import</button>
            </div>
          </div>
          <div class="moduleBd">
            <div class="tinyHint">Export gives you JSON for schedule settings + checklist + ring nodes. Import restores it.</div>
          </div>
        </div>

        <!-- Schedule setup (collapsed by default) -->
        <div class="module" id="setupModule">
          <div class="moduleHd">
            <b>Schedule Setup</b>
            <div class="mini">
              <button class="btn btnGhost" id="toggleSetup" type="button">Expand</button>
              <button class="btn btnPrimary" id="saveScheduleBtn" type="button">Save</button>
            </div>
          </div>
          <div class="moduleBd" id="setupBody" style="display:none;">
            <div style="display:grid;gap:10px;">
              <div>
                <label>Blue anchor date</label>
                <input id="blueAnchor" type="text" placeholder="YYYY-MM-DD (a Monday you know is Blue)" />
                <div class="tinyHint">Used for Auto week mode when rendering the schedule in the center of the ring.</div>
              </div>
              <div>
                <label>Office hours on H block</label>
                <select id="officeHoursMode">
                  <option value="none">None</option>
                  <option value="blue">Blue week only</option>
                  <option value="gold">Gold week only</option>
                  <option value="both">Both weeks</option>
                </select>
              </div>

              <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
                <div><label>A block name</label><input id="A" type="text" placeholder="e.g., Global History 10" /></div>
                <div><label>B block name</label><input id="B" type="text" placeholder="e.g., Advanced ME History" /></div>
              </div>
              <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
                <div><label>C block name</label><input id="C" type="text" /></div>
                <div><label>D block name</label><input id="D" type="text" /></div>
              </div>
              <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
                <div><label>E block name</label><input id="E" type="text" /></div>
                <div><label>F block name</label><input id="F" type="text" /></div>
              </div>
              <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
                <div><label>G block name</label><input id="G" type="text" /></div>
                <div><label>H block name</label><input id="H" type="text" /></div>
              </div>

              <div class="tinyHint" style="margin-top:4px;">Optional: set per-block links (e.g., Drive folders). Named class periods become clickable.</div>

              <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
                <div><label>A block link</label><input id="linkA" type="text" placeholder="https://..." /></div>
                <div><label>B block link</label><input id="linkB" type="text" placeholder="https://..." /></div>
              </div>
              <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
                <div><label>C block link</label><input id="linkC" type="text" placeholder="https://..." /></div>
                <div><label>D block link</label><input id="linkD" type="text" placeholder="https://..." /></div>
              </div>
              <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
                <div><label>E block link</label><input id="linkE" type="text" placeholder="https://..." /></div>
                <div><label>F block link</label><input id="linkF" type="text" placeholder="https://..." /></div>
              </div>
              <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
                <div><label>G block link</label><input id="linkG" type="text" placeholder="https://..." /></div>
                <div><label>H block link</label><input id="linkH" type="text" placeholder="https://..." /></div>
              </div>

              <div class="tinyHint">Once saved, the center holo shows the schedule for the selected date. The blue “NOW” slider aligns to the schedule list.</div>
            </div>
          </div>
        </div>
      </div>
    </aside>
  </main>

  <!-- Export/Import Modal -->
  <div class="overlay" id="overlay">
    <div class="modal" role="dialog" aria-modal="true" aria-label="Export/Import">
      <div class="modalHd">
        <b id="modalTitle">Export</b>
        <button class="btn btnGhost" id="closeModal" type="button">Close</button>
      </div>
      <div class="modalBd">
        <div class="tinyHint" id="modalHint">Copy this JSON to move your setup to another computer.</div>
        <textarea id="jsonBox" spellcheck="false"></textarea>
        <div style="display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end;">
          <button class="btn btnGhost" id="copyJsonBtn" type="button">Copy</button>
          <button class="btn btnPrimary" id="applyJsonBtn" type="button" style="display:none;">Apply</button>
        </div>
      </div>
    </div>
  </div>

  <div class="footer">
    Wheel rotates the ring • Drag nodes to reorder • Schedule + checklist saved in your browser (localStorage) • Export JSON for portability
  </div>

  <script>
    /************************************************************
     * Helpers
     ************************************************************/
    function pad2(n){ return String(n).padStart(2,"0"); }
    function isoDate(d){
      const y = d.getFullYear();
      const m = pad2(d.getMonth()+1);
      const da = pad2(d.getDate());
      return `${y}-${m}-${da}`;
    }
    function escapeHtml(s){
      return String(s||"")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }
    function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
    function isValidISODate(s){ return /^\d{4}-\d{2}-\d{2}$/.test(s); }
    function uid(){
      return Math.random().toString(16).slice(2) + Date.now().toString(16);
    }
    function safeURL(u){
      const t = String(u||"").trim();
      if (!t) return "";
      if (/^https?:\/\//i.test(t)) return t;
      // allow users to paste "drive.google.com/..." etc.
      return "https://" + t.replace(/^\/+/, "");
    }

    /************************************************************
     * DEFAULT RING NODES
     ************************************************************/
    const defaultRingNodes = [
      { id:"dt", label:"Discussion Tracker", sub:"class-discussion", href:"https://amhagler.github.io/class-discussion/", glyph:"DT" },
      { id:"sc", label:"Seating Chart", sub:"SC", href:"https://amhagler.github.io/SC/", glyph:"SC" },
      { id:"rb", label:"Rubric", sub:"rubric", href:"https://amhagler.github.io/rubric/", glyph:"RB" },
      { id:"uc", label:"Unit Calendar", sub:"uc", href:"https://amhagler.github.io/uc/", glyph:"UC" },
      { id:"mf", label:"Mafia", sub:"mafia", href:"https://amhagler.github.io/mafia/", glyph:"MF" },
      { id:"tr", label:"Trivia", sub:"tr", href:"https://amhagler.github.io/tr/", glyph:"TR" },
      { id:"pt", label:"Portal", sub:"myschoolapp login", href:"https://geffenacademy.myschoolapp.com/app#login", glyph:"PT" },
      { id:"gb", label:"Gradebook", sub:"SIS gradebook", href:"https://geffenacademy.myschoolapp.com/sis-gradebook/gradebook/27966135?svcid=edu&addin=1", glyph:"GB" },
    ];

    /************************************************************
     * SCHEDULE DATA (Blue/Gold)
     ************************************************************/
    const blueWeek = {
      monday: [
        { time:"9:00-9:15", block:"Reading Period" },
        { time:"9:15-10:10", block:"A" },
        { time:"10:15-11:10", block:"B" },
        { time:"11:20-12:15", block:"C" },
        { time:"12:15-1:05", block:"MS/US Lunch +MS/US Clubs" },
        { time:"1:10-2:05", block:"D" },
        { time:"2:10-3:05", block:"E" },
        { time:"3:10-3:50", block:"H" }
      ],
      tuesday: [
        { time:"9:00-9:20", block:"Bulletin" },
        { time:"9:20-10:15", block:"F" },
        { time:"10:20-11:15", block:"G" },
        { time:"11:20-12:15", block:"A" },
        { time:"12:15-1:05", block:"MS/US Lunch +MS/US Clubs" },
        { time:"1:10-2:05", block:"B" },
        { time:"2:10-3:05", block:"C" },
        { time:"3:10-3:50", block:"H" }
      ],
      wednesday: [
        { time:"9:00-9:15", block:"Reading Period" },
        { time:"9:15-10:10", block:"D" },
        { time:"10:15-11:10", block:"E" },
        { time:"11:20-12:15", block:"F" },
        { time:"12:15-1:05", block:"MS/US Lunch +MS/US Clubs" },
        { time:"1:10-2:05", block:"G" },
        { time:"2:10-3:05", block:"A" },
        { time:"3:10-3:50", block:"H" }
      ],
      thursday: [
        { time:"9:00-9:15", block:"Reading Period" },
        { time:"9:15-10:10", block:"B" },
        { time:"10:15-11:10", block:"C" },
        { time:"11:20-12:15", block:"D" },
        { time:"12:15-1:05", block:"MS/US Lunch +MS/US Clubs" },
        { time:"1:10-2:05", block:"E" },
        { time:"2:10-3:05", block:"F" },
        { time:"3:10-3:50", block:"H" }
      ],
      friday: [
        { time:"8:00-8:50", block:"Educators’ Mtg." },
        { time:"9:00-9:55", block:"G" },
        { time:"10:00-10:55", block:"A" },
        { time:"11:05-12:00", block:"B" },
        { time:"12:00-1:05", block:"MS/US SuperLunch +Affinity Groups" },
        { time:"1:10-2:05", block:"C" },
        { time:"2:10-3:05", block:"D" },
        { time:"3:10-3:50", block:"H/X1" }
      ]
    };

    const goldWeek = {
      monday: [
        { time:"9:00-9:15", block:"Reading Period" },
        { time:"9:15-10:10", block:"E" },
        { time:"10:15-11:10", block:"F" },
        { time:"11:20-12:15", block:"G" },
        { time:"12:15-1:05", block:"MS/US Lunch +MS/US Clubs" },
        { time:"1:10-2:05", block:"A" },
        { time:"2:10-3:05", block:"B" },
        { time:"3:10-3:50", block:"H" }
      ],
      tuesday: [
        { time:"9:00-9:20", block:"Bulletin" },
        { time:"9:20-10:15", block:"C" },
        { time:"10:20-11:15", block:"D" },
        { time:"11:20-12:15", block:"E" },
        { time:"12:15-1:05", block:"MS/US Lunch +MS/US Clubs" },
        { time:"1:10-2:05", block:"F" },
        { time:"2:10-3:05", block:"G" },
        { time:"3:10-3:50", block:"H" }
      ],
      wednesday: [
        { time:"9:00-9:15", block:"Reading Period" },
        { time:"9:15-10:10", block:"A" },
        { time:"10:15-11:10", block:"B" },
        { time:"11:20-12:15", block:"C" },
        { time:"12:15-1:05", block:"MS/US Lunch +MS/US Clubs" },
        { time:"1:10-2:05", block:"D" },
        { time:"2:10-3:05", block:"E" },
        { time:"3:10-3:50", block:"H" }
      ],
      thursday: [
        { time:"9:00-9:15", block:"Reading Period" },
        { time:"9:15-10:10", block:"F" },
        { time:"10:15-11:10", block:"G" },
        { time:"11:20-12:15", block:"A" },
        { time:"12:15-1:05", block:"MS/US Lunch +MS/US Clubs" },
        { time:"1:10-2:05", block:"B" },
        { time:"2:10-3:05", block:"C" },
        { time:"3:10-3:50", block:"H" }
      ],
      friday: [
        { time:"8:00-8:50", block:"Educators’ Mtg." },
        { time:"9:00-9:55", block:"D" },
        { time:"10:00-10:55", block:"E" },
        { time:"11:00-11:45", block:"H" },
        { time:"11:45-12:35", block:"MS/US Lunch +MS/US Clubs" },
        { time:"12:40-1:35", block:"F" },
        { time:"1:40-2:35", block:"G" },
        { time:"2:40-3:20", block:"X3" }
      ]
    };

    const scheduleByWeek = { blue: blueWeek, gold: goldWeek };
    const dayKeys = ["sunday","monday","tuesday","wednesday","thursday","friday","saturday"];

    function parseTimeToMinutes(t){
      const [hh, mm] = t.split(":").map(Number);
      let h = hh;
      if (h >= 1 && h <= 6) h += 12; // school schedule convention
      return h * 60 + (mm||0);
    }
    function parseRange(range){
      const parts = range.split("-");
      if (parts.length !== 2) return null;
      return { start: parseTimeToMinutes(parts[0].trim()), end: parseTimeToMinutes(parts[1].trim()) };
    }

    function dayKeyFromDate(d){ return dayKeys[d.getDay()]; }
    function isClassBlock(block){ return ["A","B","C","D","E","F","G","H"].includes(block); }
    function isRealClassForJump(block){
      // “next class” jump should skip lunch/reading/bulletin AND skip H (often office hours)
      return ["A","B","C","D","E","F","G"].includes(block);
    }

    /************************************************************
     * LOCAL STORAGE STATE
     ************************************************************/
    const LS_KEY = "geffen_cockpit_v5";

    const defaultState = {
      blueAnchor: "",
      officeHoursMode: "none",
      blocks: { A:"",B:"",C:"",D:"",E:"",F:"",G:"",H:"" },
      links:  { A:"",B:"",C:"",D:"",E:"",F:"",G:"",H:"" },
      viewDate: "",
      checklist: [], // {id, text, done}
      checkFilter: "ALL",
      ringNodes: structuredClone(defaultRingNodes),
      fxLevel: 2
    };

    function loadState(){
      try{
        const raw = localStorage.getItem(LS_KEY);
        if (!raw) return structuredClone(defaultState);
        const obj = JSON.parse(raw);

        // ring nodes: migrate from older "links" array if present
        let ringNodes = Array.isArray(obj.ringNodes) ? obj.ringNodes : null;

        if (!ringNodes && Array.isArray(obj.linksArray)){
          ringNodes = obj.linksArray;
        }

        if (!ringNodes){
          // migration from previous file where ring was const `links` (not stored)
          ringNodes = structuredClone(defaultRingNodes);
        }

        ringNodes = ringNodes.map((n, i) => ({
          id: String(n.id || n.label || "node_"+i).slice(0, 48) + "_" + i,
          label: String(n.label || "Node"),
          sub: String(n.sub || ""),
          href: String(n.href || ""),
          glyph: String(n.glyph || "").slice(0, 3) || "ND"
        }));

        return {
          ...structuredClone(defaultState),
          ...obj,
          blocks: { ...structuredClone(defaultState.blocks), ...(obj.blocks||{}) },
          links:  { ...structuredClone(defaultState.links),  ...(obj.links||{}) },
          checklist: Array.isArray(obj.checklist) ? obj.checklist : [],
          ringNodes,
          fxLevel: Number.isFinite(obj.fxLevel) ? obj.fxLevel : 2
        };
      }catch(e){
        return structuredClone(defaultState);
      }
    }
    function saveState(){
      localStorage.setItem(LS_KEY, JSON.stringify(state));
    }

    let state = loadState();

    /************************************************************
     * UI refs
     ************************************************************/
    const ring = document.getElementById("ring");
    const bayEl = document.getElementById("bay");
    const cockpitEl = document.getElementById("cockpit");
    const topbarEl = document.querySelector(".topbar");

    // schedule / date controls
    const viewDateEl = document.getElementById("viewDate");
    const btnToday = document.getElementById("btnToday");
    const btnTomorrow = document.getElementById("btnTomorrow");
    const btnNextSchool = document.getElementById("btnNextSchool");
    const btnScrollNow = document.getElementById("btnScrollNow");
    const btnJumpNext = document.getElementById("btnJumpNext");

    // center holo
    const holoList = document.getElementById("holoList");
    const holoStatus = document.getElementById("holoStatus");
    const holoTag = document.getElementById("holoTag");
    const timeMarker = document.getElementById("timeMarker");
    const timeMarkerTag = document.getElementById("timeMarkerTag");
    const energyFill = document.getElementById("energyFill");
    const energyPct = document.getElementById("energyPct");
    const energyNote = document.getElementById("energyNote");
    const dayModePill = document.getElementById("dayModePill");

    // clock + countdown
    const dateStr = document.getElementById("dateStr");
    const timeStr = document.getElementById("timeStr");
    const ticksStr = document.getElementById("ticksStr");
    const countdownBox = document.getElementById("countdownBox");
    const countdownText = document.getElementById("countdownText");
    const nextClassCard = document.getElementById("nextClassCard");
    const nextClassTitle = document.getElementById("nextClassTitle");
    const nextClassSub = document.getElementById("nextClassSub");
    const nextClassOpenBtn = document.getElementById("nextClassOpenBtn");

    // checklist
    const newItemText = document.getElementById("newItemText");
    const addItemBtn = document.getElementById("addItemBtn");
    const clearCheckedBtn = document.getElementById("clearCheckedBtn");
    const exportChecklistBtn = document.getElementById("exportChecklistBtn");
    const checkListEl = document.getElementById("checkList");
    const checkFiltersEl = document.getElementById("checkFilters");

    // schedule setup
    const blueAnchorEl = document.getElementById("blueAnchor");
    const officeHoursModeEl = document.getElementById("officeHoursMode");
    const blockEls = ["A","B","C","D","E","F","G","H"].reduce((acc,k)=>{ acc[k]=document.getElementById(k); return acc; },{});
    const linkEls  = ["A","B","C","D","E","F","G","H"].reduce((acc,k)=>{ acc[k]=document.getElementById("link"+k); return acc; },{});
    const saveScheduleBtn = document.getElementById("saveScheduleBtn");
    const toggleSetupBtn = document.getElementById("toggleSetup");
    const setupBody = document.getElementById("setupBody");

    // ring editor
    const ringSelect = document.getElementById("ringSelect");
    const ringLabel = document.getElementById("ringLabel");
    const ringSub = document.getElementById("ringSub");
    const ringHref = document.getElementById("ringHref");
    const ringGlyph = document.getElementById("ringGlyph");
    const ringNewBtn = document.getElementById("ringNewBtn");
    const ringSaveBtn = document.getElementById("ringSaveBtn");
    const ringDeleteBtn = document.getElementById("ringDeleteBtn");

    // export/import
    const overlay = document.getElementById("overlay");
    const modalTitle = document.getElementById("modalTitle");
    const modalHint = document.getElementById("modalHint");
    const jsonBox = document.getElementById("jsonBox");
    const closeModal = document.getElementById("closeModal");
    const copyJsonBtn = document.getElementById("copyJsonBtn");
    const applyJsonBtn = document.getElementById("applyJsonBtn");
    const exportBtn = document.getElementById("exportBtn");
    const importBtn = document.getElementById("importBtn");

    // FX
    const fxRange = document.getElementById("fxRange");
    const fxLabel = document.getElementById("fxLabel");

    /************************************************************
     * FX intensity
     ************************************************************/
    const FX_LEVELS = [
      { name:"OFF", matrixOpacity:0.0, matrixSpeed:0.0, boltEvery:[999999,999999], boltStrength:0.0, glow:0.55 },
      { name:"LOW", matrixOpacity:0.28, matrixSpeed:0.65, boltEvery:[3200,6200], boltStrength:0.65, glow:0.75 },
      { name:"MED", matrixOpacity:0.55, matrixSpeed:1.00, boltEvery:[1400,4600], boltStrength:1.00, glow:1.00 },
      { name:"HIGH", matrixOpacity:0.72, matrixSpeed:1.28, boltEvery:[900,3200], boltStrength:1.25, glow:1.15 },
    ];
    function applyFXLevel(level){
      const L = FX_LEVELS[level] || FX_LEVELS[2];
      fxLabel.textContent = L.name;
      document.documentElement.style.setProperty("--matrixOpacity", String(L.matrixOpacity));
      document.documentElement.style.setProperty("--fxGlow", String(L.glow));
      fxRange.value = String(level);
      state.fxLevel = level;
      saveState();
      fxConfig.matrixSpeed = L.matrixSpeed;
      fxConfig.boltEvery = L.boltEvery;
      fxConfig.boltStrength = L.boltStrength;

      // if FX is off, clear active bolts immediately for cleanliness
      if (level === 0){
        bolts.length = 0;
      }
      restartSparkScheduler();
    }

    fxRange.value = String(state.fxLevel ?? 2);
    applyFXLevel(Number(fxRange.value));
    fxRange.addEventListener("input", ()=> applyFXLevel(Number(fxRange.value)));

    /************************************************************
     * CLOCK (hundredths)
     ************************************************************/
    let rafClock = 0;
    function tickClock(){
      const now = new Date();
      dateStr.textContent = isoDate(now);
      timeStr.textContent = `${pad2(now.getHours())}:${pad2(now.getMinutes())}:${pad2(now.getSeconds())}`;
      ticksStr.textContent = `.${pad2(Math.floor(now.getMilliseconds()/10))}`;
      rafClock = requestAnimationFrame(tickClock);
    }
    tickClock();

    /************************************************************
     * Setup UI hydrate/save
     ************************************************************/
    function hydrateSetupUI(){
      blueAnchorEl.value = state.blueAnchor || "";
      officeHoursModeEl.value = state.officeHoursMode || "none";
      for (const k of Object.keys(blockEls)) blockEls[k].value = state.blocks[k] || "";
      for (const k of Object.keys(linkEls)) linkEls[k].value = state.links[k] || "";
    }
    hydrateSetupUI();

    let setupCollapsed = true;
    toggleSetupBtn.addEventListener("click", () => {
      setupCollapsed = !setupCollapsed;
      setupBody.style.display = setupCollapsed ? "none" : "";
      toggleSetupBtn.textContent = setupCollapsed ? "Expand" : "Collapse";
    });

    saveScheduleBtn.addEventListener("click", () => {
      state.blueAnchor = (blueAnchorEl.value || "").trim();
      state.officeHoursMode = officeHoursModeEl.value;
      for (const k of Object.keys(blockEls)) state.blocks[k] = (blockEls[k].value || "").trim();
      for (const k of Object.keys(linkEls))  state.links[k]  = (linkEls[k].value || "").trim();
      saveState();
      renderCenterScheduleAndTimers({ reason:"saveSchedule" });
      flashPill("Saved");
    });

    function flashPill(msg){
      const old = dayModePill.textContent;
      dayModePill.textContent = msg;
      setTimeout(()=> dayModePill.textContent = old, 900);
    }

    /************************************************************
     * View date + quick date controls
     ************************************************************/
    const todayISO = isoDate(new Date());
    if (!isValidISODate(state.viewDate)) state.viewDate = todayISO;
    viewDateEl.value = state.viewDate;

    function setViewDate(val, opts={}){
      if (!isValidISODate(val)) return;
      state.viewDate = val;
      saveState();
      viewDateEl.value = val;
      renderCenterScheduleAndTimers({ reason:"setViewDate", ...opts });
    }
    viewDateEl.addEventListener("change", (e)=> setViewDate(e.target.value, { user:true }));

    function addDays(iso, n){
      const d = new Date(iso + "T00:00:00");
      d.setDate(d.getDate() + n);
      return isoDate(d);
    }
    function nextSchoolDay(iso){
      let d = new Date(iso + "T00:00:00");
      do{
        d.setDate(d.getDate()+1);
      } while (d.getDay() === 0 || d.getDay() === 6);
      return isoDate(d);
    }

    btnToday.addEventListener("click", ()=> setViewDate(todayISO, { autoScrollNow:true }));
    btnTomorrow.addEventListener("click", ()=> setViewDate(addDays(todayISO, 1)));
    btnNextSchool.addEventListener("click", ()=> setViewDate(nextSchoolDay(todayISO)));
    btnScrollNow.addEventListener("click", ()=> {
      if (state.viewDate !== todayISO) return;
      scrollScheduleToNowCentered();
    });
    btnJumpNext.addEventListener("click", ()=> {
      if (state.viewDate !== todayISO) return;
      scrollScheduleToNextClass();
    });

    /************************************************************
     * Blue/Gold auto mode (anchor-date based)
     ************************************************************/
    function getWeekModeForDate(date){
      if (!isValidISODate(state.blueAnchor)) return null;
      const anchor = new Date(state.blueAnchor + "T00:00:00");
      const d = new Date(date.getFullYear(), date.getMonth(), date.getDate());

      const toMonday = (x) => {
        const dd = new Date(x.getFullYear(), x.getMonth(), x.getDate());
        const dow = dd.getDay();
        const diff = (dow + 6) % 7; // convert Sun=0..Sat=6 to Mon-based offset
        dd.setDate(dd.getDate() - diff);
        return dd;
      };

      const aMon = toMonday(anchor);
      const dMon = toMonday(d);

      const weeksDiff = Math.round((dMon - aMon) / (7*24*60*60*1000));
      return (weeksDiff % 2 === 0) ? "blue" : "gold";
    }

    function blockLabel(block, weekForDate){
      const misc = [
        "MS/US Lunch +MS/US Clubs",
        "MS/US SuperLunch +Affinity Groups",
        "H/X1",
        "X3",
        "Educators’ Mtg.",
        "Reading Period",
        "Bulletin"
      ];
      if (misc.includes(block)) return { label:block, named:false, blockKey:null };

      if (block === "H"){
        const mode = state.officeHoursMode || "none";
        if ((mode === "both") ||
            (mode === "blue" && weekForDate === "blue") ||
            (mode === "gold" && weekForDate === "gold")){
          return { label:"Office Hours", named:true, blockKey:"H" };
        }
      }
      const hasName = !!(state.blocks[block] && state.blocks[block].trim());
      return { label: hasName ? `${state.blocks[block]} (${block})` : block, named: hasName, blockKey:block };
    }

    function buildPeriodsForDate(dateObj){
      const dk = dayKeyFromDate(dateObj);
      if (dk === "sunday" || dk === "saturday") return { periods: [], week:null, day:dk };

      const week = getWeekModeForDate(dateObj);
      if (!week) return { periods: [], week:null, day:dk };

      const src = scheduleByWeek[week]?.[dk] || [];
      const periods = src.map(p => {
        const range = parseRange(p.time);
        const meta = blockLabel(p.block, week);
        return {
          ...p,
          label: meta.label,
          named: meta.named,
          blockKey: meta.blockKey,
          range
        };
      }).filter(p => p.range);

      return { periods, week, day:dk };
    }

    /************************************************************
     * Next class helpers
     ************************************************************/
    function findNextPeriod(periods, minutesNow, predicate){
      let best = null;
      for (const p of periods){
        if (!p.range) continue;
        if (p.range.start <= minutesNow) continue;
        if (!predicate(p)) continue;
        if (!best || p.range.start < best.range.start) best = p;
      }
      return best;
    }

    function formatCountdown(totalSec){
      const m = Math.floor(totalSec / 60);
      const s = totalSec % 60;
      return `${m}:${pad2(s)}`;
    }

    function updateCountdown(textOrNull, warn){
      if (textOrNull === null){
        countdownText.textContent = "—";
        countdownBox.classList.remove("warn");
        return;
      }
      countdownText.textContent = textOrNull;
      if (warn) countdownBox.classList.add("warn");
      else countdownBox.classList.remove("warn");
    }

    function formatStartTime(mins){
      const h24 = Math.floor(mins / 60);
      const m = mins % 60;
      const suffix = h24 >= 12 ? "PM" : "AM";
      let h12 = h24 % 12;
      if (h12 === 0) h12 = 12;
      return `${h12}:${pad2(m)} ${suffix}`;
    }

    /************************************************************
     * Center holo schedule + energy + countdown + time marker
     ************************************************************/
    let lastAutoScrollKey = ""; // prevents constant re-centering while you scroll
    let lastRenderedTodayKey = ""; // throttle initial auto-scroll when switching to today
    let latestTodayPeriodsCache = null; // for jump buttons

    function renderCenterScheduleAndTimers(opts = {}){
      const view = new Date(state.viewDate + "T00:00:00");
      const now = new Date();
      const isToday = isoDate(now) === state.viewDate;

      const { periods, week, day } = buildPeriodsForDate(view);
      const dayName = day.charAt(0).toUpperCase() + day.slice(1);
      const weekName = week ? week.toUpperCase() : "—";

      if (!week && (day === "saturday" || day === "sunday")){
        dayModePill.textContent = `Weekend • ${dayName}`;
      } else if (!week){
        dayModePill.textContent = `Auto needs anchor`;
      } else {
        dayModePill.textContent = `${weekName} • ${dayName}`;
      }

      const minutesNow = now.getHours()*60 + now.getMinutes() + now.getSeconds()/60;

      holoTag.textContent = `Daily Schedule • ${state.viewDate}`;
      holoStatus.textContent = week ? `${weekName} • ${dayName}` : (dayName);

      timeMarker.classList.remove("on");
      latestTodayPeriodsCache = isToday ? periods : null;

      // hide next-class mini card by default
      nextClassCard.classList.remove("on");
      nextClassOpenBtn.style.display = "none";

      if (!periods.length){
        holoList.innerHTML = `
          <div class="periodCard misc">
            <div class="t">—</div>
            <div class="lbl">${(day==="saturday"||day==="sunday") ? "Weekend." : "Set Blue anchor date + save block names (and links, if you want)."} </div>
          </div>
        `;
        energyFill.style.width = "0%";
        energyPct.textContent = "0%";
        energyNote.textContent = (day==="saturday"||day==="sunday") ? "Standby" : "Awaiting schedule…";
        updateCountdown(null, false);
        return;
      }

      // render period cards
      holoList.innerHTML = "";
      const frag = document.createDocumentFragment();

      for (let i=0; i<periods.length; i++){
        const p = periods[i];
        const isNow = isToday && (minutesNow >= p.range.start && minutesNow < p.range.end);

        const card = document.createElement("div");
        const isMisc = !isClassBlock(p.block);
        const named = !!p.named;

        card.className = "periodCard"
          + (isMisc ? " misc" : "")
          + (!isMisc && named ? " named" : "")
          + (isNow ? " now" : "");

        // tag for scrolling helpers
        card.dataset.block = p.block;
        card.dataset.start = String(p.range.start);
        card.dataset.end = String(p.range.end);

        const link = (p.blockKey && (state.links[p.blockKey] || "").trim()) || "";
        const safeLabel = escapeHtml(p.label);
        const safeTime = escapeHtml(p.time);

        let labelHTML = safeLabel;

        if (!isMisc && named && link){
          const u = escapeHtml(safeURL(link));
          labelHTML = `
            <a class="periodLink" href="${u}" target="_blank" rel="noopener">
              <span style="min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${safeLabel}</span>
              <span class="linkBadge">OPEN</span>
            </a>
          `;
        }

        card.innerHTML = `
          <div class="t">${safeTime}</div>
          <div class="lbl">${labelHTML}</div>
        `;

        frag.appendChild(card);
      }
      holoList.appendChild(frag);

      // energy + countdown only for today
      if (!isToday){
        energyFill.style.width = "0%";
        energyPct.textContent = "—";
        energyNote.textContent = "Energy grid is live only for today";
        updateCountdown("—", false);
        return;
      }

      const lastEnd = Math.max(...periods.map(p => p.range.end));
      const firstStart = Math.min(...periods.map(p => p.range.start));
      const clamped = clamp(minutesNow, firstStart, lastEnd);
      const prog = (clamped - firstStart) / (lastEnd - firstStart || 1);
      const pct = Math.round(prog * 100);

      energyFill.style.width = `${pct}%`;
      energyPct.textContent = `${pct}%`;

      if (minutesNow < firstStart) energyNote.textContent = "Pre-start";
      else if (minutesNow >= lastEnd) energyNote.textContent = "Complete";
      else energyNote.textContent = "In progress";

      // next class countdown (A–G–H considered “class blocks”; but countdown uses A–H)
      const nextClass = findNextPeriod(periods, minutesNow, (p)=> isClassBlock(p.block));
      if (!nextClass){
        updateCountdown("No more classes", false);
        nextClassCard.classList.remove("on");
      } else {
        const deltaSec = Math.max(0, Math.round((nextClass.range.start - minutesNow) * 60));
        const warn = deltaSec > 0 && deltaSec <= 600;
        updateCountdown(formatCountdown(deltaSec), warn);

        // actionable mini-card
        const startLabel = formatStartTime(Math.round(nextClass.range.start));
        const b = nextClass.block;
        const blockName = nextClass.named ? nextClass.label : (state.blocks[b] ? `${state.blocks[b]} (${b})` : b);
        nextClassTitle.textContent = blockName;
        nextClassSub.textContent = `Block ${b} • ${startLabel}`;

        const link = (nextClass.blockKey && (state.links[nextClass.blockKey] || "").trim()) || "";
        if (link){
          nextClassOpenBtn.style.display = "";
          nextClassOpenBtn.onclick = ()=> window.open(safeURL(link), "_blank", "noopener");
        } else {
          nextClassOpenBtn.style.display = "none";
          nextClassOpenBtn.onclick = null;
        }
        nextClassCard.classList.add("on");
      }

      // time marker: align to scrollable content, not just visible height
      timeMarker.classList.add("on");
      timeMarkerTag.textContent = `${pad2(now.getHours())}:${pad2(now.getMinutes())}`;

      const scrollH = holoList.scrollHeight;
      const viewH = holoList.clientHeight;
      const padTop = 10;  // matches holoList padding
      const padBottom = 10;

      const ratio = (clamped - firstStart) / (lastEnd - firstStart || 1);
      const yInContent = padTop + ratio * Math.max(1, (scrollH - padTop - padBottom));
      const yInViewport = yInContent - holoList.scrollTop;
      timeMarker.style.top = `${Math.round(yInViewport)}px`;

      // auto-scroll center schedule to “now” (today only), but do not fight user scrolling
      const autoKey = `${state.viewDate}|${weekName}|${dayName}`;
      if (isToday){
        const firstTimeViewingToday = (lastRenderedTodayKey !== autoKey);
        if (opts.autoScrollNow || firstTimeViewingToday){
          lastRenderedTodayKey = autoKey;
          scrollScheduleToNowCentered(true);
        }
      } else {
        lastRenderedTodayKey = "";
      }
    }

    function scrollScheduleToNowCentered(force=false){
      const now = new Date();
      if (isoDate(now) !== state.viewDate) return;

      // don't re-center every tick while user is using the scroll
      const key = `${state.viewDate}|${Math.floor(now.getMinutes()/2)}`; // coarse time bucket
      if (!force && lastAutoScrollKey === key) return;
      lastAutoScrollKey = key;

      const cards = Array.from(holoList.querySelectorAll(".periodCard"));
      if (!cards.length) return;

      const minutesNow = now.getHours()*60 + now.getMinutes() + now.getSeconds()/60;

      // prefer the currently-active period; else nearest future; else last
      let target = cards.find(c => c.classList.contains("now"));
      if (!target){
        target = cards.find(c => Number(c.dataset.start) > minutesNow) || cards[cards.length-1];
      }

      const top = target.offsetTop;
      const targetCenter = top + (target.offsetHeight/2);
      const scrollTo = clamp(targetCenter - holoList.clientHeight/2, 0, holoList.scrollHeight - holoList.clientHeight);
      holoList.scrollTo({ top: scrollTo, behavior: "smooth" });
    }

    function scrollScheduleToNextClass(){
      const now = new Date();
      if (isoDate(now) !== state.viewDate) return;

      const minutesNow = now.getHours()*60 + now.getMinutes() + now.getSeconds()/60;
      const cards = Array.from(holoList.querySelectorAll(".periodCard"));
      if (!cards.length) return;

      // next real class (A–G), skip reading/lunch/bulletin and skip H
      const nextCard = cards.find(c => isRealClassForJump(c.dataset.block) && Number(c.dataset.start) > minutesNow);
      if (!nextCard) return;

      const top = nextCard.offsetTop;
      const targetCenter = top + (nextCard.offsetHeight/2);
      const scrollTo = clamp(targetCenter - holoList.clientHeight/2, 0, holoList.scrollHeight - holoList.clientHeight);
      holoList.scrollTo({ top: scrollTo, behavior: "smooth" });
    }

    // keep marker aligned while scrolling
    holoList.addEventListener("scroll", ()=>{
      // fast recompute marker position from current render caches
      // (we simply re-run render with "no auto scroll" behavior)
      // This is light enough: just adjusts marker top + does not rebuild if not needed.
      // But to avoid rebuild, we call a targeted updater:
      updateMarkerOnly();
    }, { passive:true });

    function updateMarkerOnly(){
      const now = new Date();
      const isToday = isoDate(now) === state.viewDate;
      if (!isToday || !latestTodayPeriodsCache || !latestTodayPeriodsCache.length) return;

      const periods = latestTodayPeriodsCache;
      const minutesNow = now.getHours()*60 + now.getMinutes() + now.getSeconds()/60;

      const lastEnd = Math.max(...periods.map(p => p.range.end));
      const firstStart = Math.min(...periods.map(p => p.range.start));
      const clampedNow = clamp(minutesNow, firstStart, lastEnd);

      const ratio = (clampedNow - firstStart) / (lastEnd - firstStart || 1);
      const scrollH = holoList.scrollHeight;
      const padTop = 10, padBottom = 10;
      const yInContent = padTop + ratio * Math.max(1, (scrollH - padTop - padBottom));
      const yInViewport = yInContent - holoList.scrollTop;

      timeMarker.style.top = `${Math.round(yInViewport)}px`;
      timeMarkerTag.textContent = `${pad2(now.getHours())}:${pad2(now.getMinutes())}`;
      timeMarker.classList.add("on");
    }

    // periodic render (timers + marker + countdown)
    let scheduleTimer = 0;
    function startScheduleTimer(){
      if (scheduleTimer) clearInterval(scheduleTimer);
      scheduleTimer = setInterval(()=> renderCenterScheduleAndTimers({ reason:"tick" }), 700);
    }
    startScheduleTimer();

    /************************************************************
     * Ring: adaptive sizing + layout + drag reorder + keyboard nav
     ************************************************************/
    let rotation = 0; // radians
    let targetRotation = 0;
    let rafRing = 0;
    let focusedIdx = 0;

    function applyAdaptiveRingSizing(){
      const n = state.ringNodes.length;
      // size range tuned for readability
      let w, h, pad, inset;
      if (n <= 6){ w = 148; h = 148; pad = 44; inset = 195; }
      else if (n <= 8){ w = 136; h = 136; pad = 42; inset = 200; }
      else if (n <= 10){ w = 126; h = 126; pad = 40; inset = 205; }
      else if (n <= 12){ w = 116; h = 116; pad = 38; inset = 208; }
      else { w = 108; h = 108; pad = 36; inset = 210; }

      const root = document.documentElement.style;
      root.setProperty("--nodeW", w+"px");
      root.setProperty("--nodeH", h+"px");
      root.setProperty("--ringPad", pad+"px");
      root.setProperty("--holoInset", inset+"px");
    }

    function buildNodes(){
      applyAdaptiveRingSizing();
      ring.querySelectorAll(".node").forEach(n => n.remove());

      state.ringNodes.forEach((l, idx) => {
        const node = document.createElement("div");
        node.className = "node";
        node.dataset.idx = String(idx);
        node.dataset.id = String(l.id);

        node.innerHTML = `
          <a class="cardLink" href="${escapeHtml(safeURL(l.href))}" target="_blank" rel="noopener"
             aria-label="${escapeHtml(l.label)}" tabindex="-1">
            <div class="glyph">${escapeHtml(l.glyph)}</div>
            <div class="cardTitle">${escapeHtml(l.label)}</div>
            <div class="cardSub">${escapeHtml(l.sub)}</div>
          </a>
        `;

        // hover sets focus
        node.addEventListener("pointerenter", ()=>{
          focusedIdx = Number(node.dataset.idx) || 0;
          updateFocusedNode();
        });

        // click open (normal link works); also allow clicking the whole node reliably
        node.addEventListener("click", (e)=>{
          // if drag just happened, suppress click
          if (dragState.active && dragState.moved) {
            e.preventDefault();
            e.stopPropagation();
          }
        }, true);

        ring.appendChild(node);
      });

      updateFocusedNode();
    }

    function updateFocusedNode(){
      const nodes = Array.from(ring.querySelectorAll(".node"));
      nodes.forEach(n => n.classList.remove("focused"));
      const f = nodes[clamp(focusedIdx, 0, nodes.length-1)];
      if (f) f.classList.add("focused");
    }

    function computeOrbitRadius(){
      const cs = getComputedStyle(document.documentElement);
      const nodeW = parseFloat(cs.getPropertyValue("--nodeW")) || 132;
      const ringPad = parseFloat(cs.getPropertyValue("--ringPad")) || 40;
      const w = ring.clientWidth || 600;
      const half = w / 2;
      // add a little breathing room so nodes never clip inside bay
      return Math.max(170, half - (nodeW / 2) - ringPad);
    }

    function layoutNodes(){
      const nodes = Array.from(ring.querySelectorAll(".node"));
      const r = computeOrbitRadius();
      const n = nodes.length || 1;

      for (let i = 0; i < n; i++){
        const theta = (Math.PI * 2) * (i / n) + rotation;
        const x = Math.cos(theta) * r;
        const y = Math.sin(theta) * r;
        nodes[i].style.transform = `translate(calc(-50% + ${x}px), calc(-50% + ${y}px))`;
        nodes[i].dataset.theta = String(theta);
      }
    }

    ring.addEventListener("wheel", (e) => {
      e.preventDefault();
      targetRotation += (e.deltaY || 0) * 0.0022;
    }, { passive:false });

    function animateRing(){
      if (fxPaused) return;
      rotation += (targetRotation - rotation) * 0.10;
      layoutNodes();
      rafRing = requestAnimationFrame(animateRing);
    }

    // Keyboard nav (doesn't break wheel)
    ring.addEventListener("keydown", (e)=>{
      const nodes = state.ringNodes.length || 1;
      if (e.key === "ArrowLeft"){
        targetRotation -= (Math.PI * 2) / nodes;
        focusedIdx = (focusedIdx - 1 + nodes) % nodes;
        updateFocusedNode();
        e.preventDefault();
      } else if (e.key === "ArrowRight"){
        targetRotation += (Math.PI * 2) / nodes;
        focusedIdx = (focusedIdx + 1) % nodes;
        updateFocusedNode();
        e.preventDefault();
      } else if (e.key === "Enter"){
        const node = state.ringNodes[clamp(focusedIdx, 0, nodes-1)];
        if (node && node.href){
          window.open(safeURL(node.href), "_blank", "noopener");
        }
        e.preventDefault();
      }
    });

    // Drag reorder (mouse/touch)
    const dragState = {
      active:false,
      moved:false,
      pointerId:null,
      startIdx:-1
    };

    function pointerToAngle(clientX, clientY){
      const r = ring.getBoundingClientRect();
      const cx = r.left + r.width/2;
      const cy = r.top + r.height/2;
      return Math.atan2(clientY - cy, clientX - cx);
    }

    function normalizeAngle(a){
      while (a < 0) a += Math.PI*2;
      while (a >= Math.PI*2) a -= Math.PI*2;
      return a;
    }

    function indexFromAngle(angle, n){
      // convert pointer angle to nearest index, compensating for current rotation
      const a = normalizeAngle(angle - rotation);
      const idx = Math.round((a / (Math.PI*2)) * n) % n;
      return idx;
    }

    function moveArray(arr, from, to){
      if (from === to) return;
      const x = arr.splice(from, 1)[0];
      arr.splice(to, 0, x);
    }

    function attachNodeDragHandlers(){
      ring.querySelectorAll(".node").forEach(node=>{
        node.addEventListener("pointerdown", (e)=>{
          // start drag only if not clicking the internal link normally (but we still allow drag from anywhere)
          dragState.active = true;
          dragState.moved = false;
          dragState.pointerId = e.pointerId;
          dragState.startIdx = Number(node.dataset.idx) || 0;
          node.setPointerCapture(e.pointerId);
          node.classList.add("dragging");
          e.preventDefault();
        });

        node.addEventListener("pointermove", (e)=>{
          if (!dragState.active || dragState.pointerId !== e.pointerId) return;
          const nodes = state.ringNodes.length;
          if (!nodes) return;

          const ang = pointerToAngle(e.clientX, e.clientY);
          const toIdx = indexFromAngle(ang, nodes);
          const fromIdx = Number(node.dataset.idx) || 0;

          if (toIdx !== fromIdx){
            dragState.moved = true;
            // reorder data
            moveArray(state.ringNodes, fromIdx, toIdx);
            saveState();

            // rebuild DOM quickly so indices update cleanly
            buildNodes();
            attachNodeDragHandlers();
            renderRingEditorSelect();
            focusedIdx = toIdx;
            updateFocusedNode();
            layoutNodes();
          }
        });

        node.addEventListener("pointerup", (e)=>{
          if (!dragState.active || dragState.pointerId !== e.pointerId) return;
          dragState.active = false;
          dragState.pointerId = null;
          node.classList.remove("dragging");
          setTimeout(()=> { dragState.moved = false; }, 0);
        });

        node.addEventListener("pointercancel", ()=>{
          dragState.active = false;
          dragState.pointerId = null;
          node.classList.remove("dragging");
        });
      });
    }

    buildNodes();
    attachNodeDragHandlers();
    layoutNodes();
    animateRing();

    /************************************************************
     * Ring node editor UI
     ************************************************************/
    function renderRingEditorSelect(){
      ringSelect.innerHTML = "";
      state.ringNodes.forEach((n, i)=>{
        const opt = document.createElement("option");
        opt.value = n.id;
        opt.textContent = `${i+1}. ${n.label}`;
        ringSelect.appendChild(opt);
      });

      if (!state.ringNodes.length){
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "(No nodes)";
        ringSelect.appendChild(opt);
      }
    }

    function loadRingFormById(id){
      const node = state.ringNodes.find(n => n.id === id) || state.ringNodes[0];
      if (!node){
        ringLabel.value = "";
        ringSub.value = "";
        ringHref.value = "";
        ringGlyph.value = "";
        return;
      }
      ringSelect.value = node.id;
      ringLabel.value = node.label || "";
      ringSub.value = node.sub || "";
      ringHref.value = node.href || "";
      ringGlyph.value = node.glyph || "";
    }

    renderRingEditorSelect();
    loadRingFormById(state.ringNodes[0]?.id || "");

    ringSelect.addEventListener("change", ()=> loadRingFormById(ringSelect.value));

    ringNewBtn.addEventListener("click", ()=>{
      const newNode = {
        id: "node_" + uid().slice(0,8),
        label: "New Node",
        sub: "subtext",
        href: "https://",
        glyph: "NEW"
      };
      state.ringNodes.push(newNode);
      saveState();
      buildNodes();
      attachNodeDragHandlers();
      layoutNodes();
      renderRingEditorSelect();
      loadRingFormById(newNode.id);
      flashPill("New");
    });

    ringSaveBtn.addEventListener("click", ()=>{
      const id = ringSelect.value;
      const node = state.ringNodes.find(n => n.id === id);
      if (!node) return;

      node.label = (ringLabel.value || "").trim() || "Node";
      node.sub = (ringSub.value || "").trim();
      node.href = safeURL(ringHref.value || "");
      node.glyph = ((ringGlyph.value || "").trim().slice(0,3) || "ND");

      saveState();
      buildNodes();
      attachNodeDragHandlers();
      layoutNodes();
      renderRingEditorSelect();
      loadRingFormById(node.id);
      flashPill("Saved");
    });

    ringDeleteBtn.addEventListener("click", ()=>{
      const id = ringSelect.value;
      const idx = state.ringNodes.findIndex(n => n.id === id);
      if (idx < 0) return;
      state.ringNodes.splice(idx, 1);
      saveState();
      buildNodes();
      attachNodeDragHandlers();
      layoutNodes();
      renderRingEditorSelect();
      loadRingFormById(state.ringNodes[clamp(idx,0,state.ringNodes.length-1)]?.id || "");
      flashPill("Deleted");
    });

    /************************************************************
     * Checklist: tags + due parsing + filter pills + drag reorder
     ************************************************************/
    function parseTags(text){
      const tags = [];
      const re = /(^|\s)#([a-zA-Z][\w-]{0,24})\b/g;
      let m;
      while ((m = re.exec(text)) !== null){
        tags.push(m[2].toLowerCase());
      }
      return Array.from(new Set(tags));
    }

    function parseDue(text){
      // tokens: @today, @tomorrow, @H:MM, @HH:MM, @2:15, @14:15
      const lower = text.toLowerCase();
      const hasToday = /(^|\s)@today\b/.test(lower);
      const hasTomorrow = /(^|\s)@tomorrow\b/.test(lower);

      const timeMatch = lower.match(/(^|\s)@(\d{1,2}):(\d{2})\b/);
      const hour = timeMatch ? Number(timeMatch[2]) : null;
      const min = timeMatch ? Number(timeMatch[3]) : null;

      if (!hasToday && !hasTomorrow && hour == null) return null;

      const base = new Date();
      base.setSeconds(0,0);

      if (hasTomorrow){
        base.setDate(base.getDate()+1);
      }
      // if @today, keep base date as today

      if (hour != null && min != null && min >= 0 && min < 60){
        let h = hour;
        // interpret 1–6 as PM (school convention), otherwise 24h is allowed
        if (h >= 1 && h <= 6) h += 12;
        base.setHours(clamp(h,0,23), clamp(min,0,59), 0, 0);
      } else {
        // date-only token: treat as end-of-day
        base.setHours(23,59,0,0);
      }

      return base;
    }

    function dueBadgeLabel(due){
      if (!due) return "";
      const now = new Date();
      const sameDay = isoDate(due) === isoDate(now);
      const tomorrow = isoDate(due) === isoDate(new Date(now.getFullYear(), now.getMonth(), now.getDate()+1));
      const hm = `${pad2(due.getHours())}:${pad2(due.getMinutes())}`;

      if (sameDay) return `Due today ${hm}`;
      if (tomorrow) return `Due tomorrow ${hm}`;
      return `Due ${isoDate(due)} ${hm}`;
    }

    function getChecklistTagsUniverse(){
      const set = new Set();
      for (const it of state.checklist){
        parseTags(it.text).forEach(t => set.add(t));
      }
      return Array.from(set).sort((a,b)=> a.localeCompare(b));
    }

    function renderChecklistFilters(){
      const tags = getChecklistTagsUniverse();
      checkFiltersEl.innerHTML = "";

      const mk = (label, key)=>{
        const b = document.createElement("button");
        b.className = "filterPill" + (state.checkFilter === key ? " active" : "");
        b.type = "button";
        b.textContent = label;
        b.addEventListener("click", ()=>{
          state.checkFilter = key;
          saveState();
          renderChecklist();
        });
        return b;
      };

      checkFiltersEl.appendChild(mk("All", "ALL"));
      tags.forEach(t => checkFiltersEl.appendChild(mk("#"+t, t)));
    }

    function checklistPassesFilter(item){
      if (!state.checkFilter || state.checkFilter === "ALL") return true;
      const tags = parseTags(item.text);
      return tags.includes(state.checkFilter);
    }

    function renderChecklist(){
      renderChecklistFilters();
      checkListEl.innerHTML = "";

      const filtered = state.checklist.filter(checklistPassesFilter);

      if (!filtered.length){
        const empty = document.createElement("div");
        empty.className = "tinyHint";
        empty.textContent = state.checkFilter && state.checkFilter !== "ALL"
          ? `No items for #${state.checkFilter}.`
          : "No items yet. Add one above.";
        checkListEl.appendChild(empty);
        return;
      }

      const now = new Date();

      filtered.forEach((item) => {
        const idx = state.checklist.findIndex(it => it.id === item.id);

        const tags = parseTags(item.text);
        const due = parseDue(item.text);
        const overdue = !!(due && !item.done && due.getTime() < now.getTime());

        const row = document.createElement("div");
        row.className = "checkItem" + (item.done ? " done" : "") + (overdue ? " overdue" : "");
        row.draggable = true;
        row.dataset.id = item.id;

        const metaChips = document.createElement("div");
        metaChips.className = "checkMetaRow";

        tags.forEach(t=>{
          const chip = document.createElement("span");
          chip.className = "tagChip";
          chip.textContent = "#"+t;
          metaChips.appendChild(chip);
        });

        if (due){
          const badge = document.createElement("span");
          badge.className = "dueBadge" + (overdue ? " overdue" : "");
          badge.textContent = dueBadgeLabel(due);
          metaChips.appendChild(badge);
        }

        row.innerHTML = `
          <div class="dragGrip" title="Drag to reorder" aria-hidden="true">≡</div>
          <input type="checkbox" ${item.done ? "checked" : ""} aria-label="Toggle item">
          <div class="txtWrap">
            <div class="txt"></div>
          </div>
        `;

        row.querySelector(".txt").textContent = item.text;

        // append meta row if needed
        if (metaChips.childNodes.length){
          row.querySelector(".txtWrap").appendChild(metaChips);
        }

        const cb = row.querySelector("input[type='checkbox']");
        cb.addEventListener("change", () => {
          state.checklist[idx].done = cb.checked;
          saveState();
          renderChecklist();
        });

        // Drag reorder
        row.addEventListener("dragstart", (e)=>{
          row.classList.add("dragging");
          e.dataTransfer.setData("text/plain", item.id);
          e.dataTransfer.effectAllowed = "move";
        });
        row.addEventListener("dragend", ()=>{
          row.classList.remove("dragging");
        });
        row.addEventListener("dragover", (e)=>{
          e.preventDefault();
          e.dataTransfer.dropEffect = "move";
        });
        row.addEventListener("drop", (e)=>{
          e.preventDefault();
          const draggedId = e.dataTransfer.getData("text/plain");
          if (!draggedId || draggedId === item.id) return;

          const from = state.checklist.findIndex(it => it.id === draggedId);
          const to = state.checklist.findIndex(it => it.id === item.id);
          if (from < 0 || to < 0) return;

          moveArray(state.checklist, from, to);
          saveState();
          renderChecklist();
        });

        checkListEl.appendChild(row);
      });
    }

    function addChecklistItem(text){
      const t = (text || "").trim();
      if (!t) return;
      state.checklist.unshift({ id: uid(), text: t, done: false });
      saveState();
      newItemText.value = "";
      renderChecklist();
    }

    addItemBtn.addEventListener("click", ()=> addChecklistItem(newItemText.value));
    newItemText.addEventListener("keydown", (e)=>{
      if (e.key === "Enter"){
        e.preventDefault();
        addChecklistItem(newItemText.value);
      }
    });

    clearCheckedBtn.addEventListener("click", ()=>{
      state.checklist = state.checklist.filter(it => !it.done);
      saveState();
      renderChecklist();
    });

    exportChecklistBtn.addEventListener("click", ()=> openModal("exportChecklist"));

    renderChecklist();

    /************************************************************
     * Render schedule initially
     ************************************************************/
    renderCenterScheduleAndTimers({ autoScrollNow: (state.viewDate === todayISO) });

    /************************************************************
     * Export / Import JSON (schedule + checklist + ring nodes)
     ************************************************************/
    function openModal(mode){
      overlay.style.display = "flex";

      if (mode === "export"){
        modalTitle.textContent = "Export";
        modalHint.textContent = "Copy this JSON to move your schedule + links + checklist + ring nodes to another computer.";
        jsonBox.value = JSON.stringify(state, null, 2);
        applyJsonBtn.style.display = "none";
        jsonBox.readOnly = true;
        return;
      }

      if (mode === "exportChecklist"){
        modalTitle.textContent = "Export Checklist";
        modalHint.textContent = "Copy this JSON if you only want to move the checklist.";
        jsonBox.value = JSON.stringify({ checklist: state.checklist }, null, 2);
        applyJsonBtn.style.display = "none";
        jsonBox.readOnly = true;
        return;
      }

      modalTitle.textContent = "Import";
      modalHint.textContent = "Paste JSON exported from this dashboard and click Apply.";
      jsonBox.value = "";
      applyJsonBtn.style.display = "";
      jsonBox.readOnly = false;
    }
    function closeModalFn(){ overlay.style.display = "none"; }

    exportBtn.addEventListener("click", () => openModal("export"));
    importBtn.addEventListener("click", () => openModal("import"));
    closeModal.addEventListener("click", closeModalFn);
    overlay.addEventListener("click", (e) => { if (e.target === overlay) closeModalFn(); });

    copyJsonBtn.addEventListener("click", async () => {
      try{
        await navigator.clipboard.writeText(jsonBox.value);
        flashPill("Copied");
      }catch(e){
        jsonBox.select();
        document.execCommand("copy");
        flashPill("Copied");
      }
    });

    applyJsonBtn.addEventListener("click", () => {
      try{
        const obj = JSON.parse(jsonBox.value);
        if (typeof obj !== "object" || !obj) throw new Error("Invalid JSON");

        // checklist-only import convenience
        if (obj.checklist && !obj.blocks && !obj.blueAnchor && !obj.links && !obj.ringNodes){
          state.checklist = Array.isArray(obj.checklist) ? obj.checklist : [];
          saveState();
          renderChecklist();
          renderCenterScheduleAndTimers({ reason:"importChecklist" });
          closeModalFn();
          flashPill("Imported");
          return;
        }

        const merged = {
          ...structuredClone(defaultState),
          ...obj,
          blocks: { ...structuredClone(defaultState.blocks), ...(obj.blocks||{}) },
          links:  { ...structuredClone(defaultState.links),  ...(obj.links||{}) },
          checklist: Array.isArray(obj.checklist) ? obj.checklist : [],
          ringNodes: Array.isArray(obj.ringNodes) ? obj.ringNodes : structuredClone(defaultRingNodes),
          fxLevel: Number.isFinite(obj.fxLevel) ? obj.fxLevel : 2
        };

        // sanitize ring nodes
        merged.ringNodes = merged.ringNodes.map((n,i)=>({
          id: String(n.id || n.label || "node_"+i).slice(0,48) + "_" + i,
          label: String(n.label || "Node"),
          sub: String(n.sub || ""),
          href: String(n.href || ""),
          glyph: String(n.glyph || "").slice(0,3) || "ND"
        }));

        if (!isValidISODate(merged.viewDate)) merged.viewDate = isoDate(new Date());

        state = merged;
        saveState();

        hydrateSetupUI();
        viewDateEl.value = state.viewDate;

        applyFXLevel(Number(state.fxLevel ?? 2));

        renderChecklist();
        renderRingEditorSelect();
        loadRingFormById(state.ringNodes[0]?.id || "");
        buildNodes();
        attachNodeDragHandlers();
        layoutNodes();

        renderCenterScheduleAndTimers({ reason:"import", autoScrollNow:(state.viewDate === isoDate(new Date())) });

        closeModalFn();
        flashPill("Imported");
      }catch(e){
        alert("Import failed. Make sure you pasted valid JSON exported from this dashboard.");
      }
    });

    /************************************************************
     * Google search focus with /
     ************************************************************/
    window.addEventListener("keydown", (e) => {
      if (e.key === "/" && document.activeElement !== document.getElementById("googleQ")){
        e.preventDefault();
        document.getElementById("googleQ").focus();
      }
    });

    /************************************************************
     * Resize relayout for ring + canvases
     ************************************************************/
    window.addEventListener("resize", () => {
      layoutNodes();
      resizeMatrix();
      resizeLightning();
      updateMarkerOnly();
    });

    /************************************************************
     * MATRIX / ELECTRIC CASCADE BACKGROUND (canvas)
     ************************************************************/
    const matrixCanvas = document.getElementById("matrixBg");
    const mtx = matrixCanvas.getContext("2d", { alpha:true });

    let matrixCols = [];
    let matrixW = 0, matrixH = 0, matrixDPR = 1;
    let matrixFontPx = 14;
    let matrixStep = 16;

    const glyphs = "01░▒▓╌╎╍╏┆┇┊┋⋮⋯⟡⟢⟣⟠⟟⟞·";
    function randGlyph(){
      return glyphs[Math.floor(Math.random() * glyphs.length)];
    }

    const fxConfig = {
      matrixSpeed: 1.0,
      boltEvery: [1400, 4600],
      boltStrength: 1.0
    };

    function resizeMatrix(){
      matrixDPR = Math.max(1, window.devicePixelRatio || 1); // do not cap columns (requirement)
      matrixW = Math.floor(window.innerWidth);
      matrixH = Math.floor(window.innerHeight);
      matrixCanvas.width = Math.floor(matrixW * matrixDPR);
      matrixCanvas.height = Math.floor(matrixH * matrixDPR);
      matrixCanvas.style.width = matrixW + "px";
      matrixCanvas.style.height = matrixH + "px";

      mtx.setTransform(matrixDPR,0,0,matrixDPR,0,0);

      matrixFontPx = Math.max(12, Math.min(16, Math.floor(matrixW / 90)));
      matrixStep = Math.floor(matrixFontPx * 1.25);

      const cols = Math.floor(matrixW / matrixStep);
      matrixCols = new Array(cols).fill(0).map(() => ({
        y: Math.random() * matrixH,
        speed: 0.7 + Math.random() * 1.8,
        density: 0.08 + Math.random() * 0.22,
        glow: 0.08 + Math.random() * 0.20
      }));
      mtx.font = `${matrixFontPx}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace`;
    }

    let rafMatrix = 0;
    function stepMatrix(){
      if (fxPaused) return;

      // fade with slight tint
      mtx.fillStyle = "rgba(7, 11, 26, 0.08)";
      mtx.fillRect(0,0,matrixW,matrixH);

      const speedMul = fxConfig.matrixSpeed;

      for (let i=0; i<matrixCols.length; i++){
        const col = matrixCols[i];
        const x = i * matrixStep;

        if (Math.random() > col.density) continue;

        const ch = randGlyph();
        const y = col.y;

        mtx.shadowBlur = 14;
        mtx.shadowColor = `rgba(45,125,255,${0.22 + col.glow})`;
        mtx.fillStyle = `rgba(123,231,255,${0.18 + col.glow})`;
        mtx.fillText(ch, x, y);

        mtx.shadowBlur = 0;
        mtx.fillStyle = `rgba(75,255,211,${0.07 + col.glow * 0.7})`;
        mtx.fillText(ch, x, y);

        col.y += (col.speed * matrixStep * 0.22) * speedMul;

        if (col.y > matrixH + 50){
          col.y = -Math.random() * 200;
          col.speed = 0.7 + Math.random() * 1.8;
          col.density = 0.08 + Math.random() * 0.22;
          col.glow = 0.08 + Math.random() * 0.20;
        }
      }
      rafMatrix = requestAnimationFrame(stepMatrix);
    }

    resizeMatrix();
    stepMatrix();

    /************************************************************
     * ELECTRIC LIGHTNING (canvas overlay)
     ************************************************************/
    const fxCanvas = document.getElementById("fxLightning");
    const fx = fxCanvas.getContext("2d", { alpha:true });

    let fxW=0, fxH=0, fxDPR=1;
    function resizeLightning(){
      fxDPR = Math.max(1, window.devicePixelRatio || 1);
      fxW = window.innerWidth;
      fxH = window.innerHeight;
      fxCanvas.width = Math.floor(fxW * fxDPR);
      fxCanvas.height = Math.floor(fxH * fxDPR);
      fxCanvas.style.width = fxW + "px";
      fxCanvas.style.height = fxH + "px";
      fx.setTransform(fxDPR,0,0,fxDPR,0,0);
    }
    resizeLightning();

    function rectOf(el){
      const r = el.getBoundingClientRect();
      return { x:r.left, y:r.top, w:r.width, h:r.height };
    }

    function jitter(n, amt){ return n + (Math.random()*2-1)*amt; }

    function makeBolt(x0,y0,x1,y1,segments=16,spread=18){
      const pts = [];
      for (let i=0;i<=segments;i++){
        const t = i/segments;
        const x = x0 + (x1-x0)*t;
        const y = y0 + (y1-y0)*t;
        const dx = x1-x0, dy = y1-y0;
        const len = Math.hypot(dx,dy) || 1;
        const px = -dy/len, py = dx/len;
        const amp = (1 - Math.abs(0.5 - t)*2) * spread;
        pts.push({
          x: jitter(x + px * (Math.random()*2-1) * amp, 1.8),
          y: jitter(y + py * (Math.random()*2-1) * amp, 1.8)
        });
      }
      return pts;
    }

    function branchFrom(pts, branchChance=0.25){
      if (Math.random() > branchChance) return null;
      const idx = Math.floor(pts.length * (0.35 + Math.random()*0.4));
      const p = pts[idx];
      const angle = Math.random() * Math.PI * 2;
      const dist = 40 + Math.random()*90;
      const x1 = p.x + Math.cos(angle)*dist;
      const y1 = p.y + Math.sin(angle)*dist;
      return makeBolt(p.x,p.y,x1,y1, 8+Math.floor(Math.random()*6), 10+Math.random()*10);
    }

    const bolts = []; // {pts, born, life, w, branches:[pts...]}

    function spawnBorderBolt(targetEl, edge="random"){
      if (fxConfig.boltStrength <= 0.01) return;

      const r = rectOf(targetEl);
      const inset = 2;
      const pick = edge === "random" ? ["top","right","bottom","left"][Math.floor(Math.random()*4)] : edge;

      let x0,y0,x1,y1;
      if (pick === "top"){
        x0 = r.x + inset + Math.random()*(r.w - inset*2);
        y0 = r.y + inset;
        x1 = x0; y1 = y0;
      } else if (pick === "bottom"){
        x0 = r.x + inset + Math.random()*(r.w - inset*2);
        y0 = r.y + r.h - inset;
        x1 = x0; y1 = y0;
      } else if (pick === "left"){
        x0 = r.x + inset;
        y0 = r.y + inset + Math.random()*(r.h - inset*2);
        x1 = x0; y1 = y0;
      } else {
        x0 = r.x + r.w - inset;
        y0 = r.y + inset + Math.random()*(r.h - inset*2);
        x1 = x0; y1 = y0;
      }

      // travel along edge
      if (pick === "top" || pick === "bottom"){
        x1 = x0 + (Math.random() > 0.5 ? 1 : -1) * (60 + Math.random()*180);
        x1 = clamp(x1, r.x + inset, r.x + r.w - inset);
      } else {
        y1 = y0 + (Math.random() > 0.5 ? 1 : -1) * (60 + Math.random()*180);
        y1 = clamp(y1, r.y + inset, r.y + r.h - inset);
      }

      const spread = 14 * fxConfig.boltStrength;
      const pts = makeBolt(x0,y0,x1,y1, 14, spread);

      const branches = [];
      const b1 = branchFrom(pts, 0.55);
      const b2 = branchFrom(pts, 0.35);
      if (b1) branches.push(b1);
      if (b2) branches.push(b2);

      bolts.push({
        pts,
        branches,
        born: performance.now(),
        life: 280 + Math.random()*520,
        w: (1.1 + Math.random()*1.4) * fxConfig.boltStrength
      });
    }

    function spawnRingArc(){
      if (fxConfig.boltStrength <= 0.01) return;

      const ringRect = rectOf(ring);
      const cx = ringRect.x + ringRect.w/2;
      const cy = ringRect.y + ringRect.h/2;
      const rad = ringRect.w/2 - 18;

      const a0 = Math.random() * Math.PI * 2;
      const a1 = a0 + (Math.random() > 0.5 ? 1 : -1) * (0.7 + Math.random()*1.0);

      const x0 = cx + Math.cos(a0)*rad;
      const y0 = cy + Math.sin(a0)*rad;
      const x1 = cx + Math.cos(a1)*rad;
      const y1 = cy + Math.sin(a1)*rad;

      const spread = 18 * fxConfig.boltStrength;
      const pts = makeBolt(x0,y0,x1,y1, 18, spread);

      bolts.push({
        pts,
        branches: [],
        born: performance.now(),
        life: 240 + Math.random()*380,
        w: (1.1 + Math.random()*1.2) * fxConfig.boltStrength
      });
    }

    function drawBoltPath(pts, alpha, width){
      fx.beginPath();
      fx.moveTo(pts[0].x, pts[0].y);
      for (let i=1;i<pts.length;i++) fx.lineTo(pts[i].x, pts[i].y);

      const glowMul = Number(getComputedStyle(document.documentElement).getPropertyValue("--fxGlow")) || 1;

      // glow underlay
      fx.globalAlpha = alpha * 0.65;
      fx.lineWidth = width * (5.0 * glowMul);
      fx.strokeStyle = "rgba(45,125,255,1)";
      fx.shadowBlur = 20 * glowMul;
      fx.shadowColor = "rgba(45,125,255,0.8)";
      fx.stroke();

      // bright core
      fx.globalAlpha = alpha;
      fx.lineWidth = width;
      fx.strokeStyle = "rgba(123,231,255,1)";
      fx.shadowBlur = 0;
      fx.stroke();
    }

    let rafLightning = 0;
    function stepLightning(){
      if (fxPaused) return;

      fx.clearRect(0,0,fxW,fxH);
      const now = performance.now();

      for (let i=bolts.length-1;i>=0;i--){
        const b = bolts[i];
        const age = now - b.born;
        const t = age / b.life;
        if (t >= 1){
          bolts.splice(i,1);
          continue;
        }
        const alpha = (t < 0.15) ? (t/0.15) : (t < 0.55 ? 1 : (1 - (t-0.55)/0.45));
        drawBoltPath(b.pts, alpha, b.w);
        for (const br of b.branches){
          drawBoltPath(br, alpha * 0.8, Math.max(0.9, b.w*0.85));
        }
      }

      rafLightning = requestAnimationFrame(stepLightning);
    }
    stepLightning();

    // periodic sparks scheduler (controlled by FX intensity + visibility pause)
    let sparkTimer = 0;
    function restartSparkScheduler(){
      if (sparkTimer) clearTimeout(sparkTimer);
      if (fxPaused) return;

      const [minMs, maxMs] = fxConfig.boltEvery;
      if (minMs > 900000) return; // OFF

      const next = minMs + Math.random()*(maxMs - minMs);
      sparkTimer = setTimeout(()=>{
        if (fxPaused) return;

        const burst = Math.random() < 0.65;
        const targets = [bayEl, cockpitEl, topbarEl];
        const count = burst ? (1 + Math.floor(Math.random()*3)) : 1;

        for (let i=0;i<count;i++){
          const t = targets[Math.floor(Math.random()*targets.length)];
          spawnBorderBolt(t, "random");
        }
        if (Math.random() < 0.35) spawnRingArc();

        restartSparkScheduler();
      }, next);
    }
    restartSparkScheduler();

    /************************************************************
     * Pause animations when tab not visible
     ************************************************************/
    let fxPaused = false;
    function pauseFX(){
      fxPaused = true;

      if (rafRing) cancelAnimationFrame(rafRing);
      if (rafMatrix) cancelAnimationFrame(rafMatrix);
      if (rafLightning) cancelAnimationFrame(rafLightning);
      if (sparkTimer) clearTimeout(sparkTimer);

      rafRing = rafMatrix = rafLightning = 0;
      sparkTimer = 0;
    }
    function resumeFX(){
      if (!fxPaused) return;
      fxPaused = false;

      // resume loops
      animateRing();
      stepMatrix();
      stepLightning();
      restartSparkScheduler();
    }

    document.addEventListener("visibilitychange", ()=>{
      if (document.visibilityState === "hidden") pauseFX();
      else resumeFX();
    });

    /************************************************************
     * Export/import modal keyboard
     ************************************************************/
    window.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && overlay.style.display === "flex"){
        overlay.style.display = "none";
      }
    });
  </script>
</body>
</html>
